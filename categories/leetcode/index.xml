<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Leetcode on yuler&#39;s blog</title>
    <link>https://yuler.asia/categories/leetcode/</link>
    <description>Recent content in Leetcode on yuler&#39;s blog</description>
    <image>
      <url>https://yuler.asia/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://yuler.asia/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 22 Jul 2021 00:53:46 +0000</lastBuildDate><atom:link href="https://yuler.asia/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>138. 复制带随机指针的链表</title>
      <link>https://yuler.asia/topics/leetcode/138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8.html</link>
      <pubDate>Thu, 22 Jul 2021 00:53:46 +0000</pubDate>
      
      <guid>https://yuler.asia/topics/leetcode/138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8.html</guid>
      <description> 题目地址
 Solution 两种解决思路：
 使用哈希表存储每个原节点对于复制节点的映射 先通过链表A-&amp;gt;B-&amp;gt;C构造A-&amp;gt;A&amp;amp;#039;-&amp;gt;B-&amp;gt;B&amp;amp;#039;-&amp;gt;C-&amp;gt;C&amp;amp;#039;，然后再拆分成A-&amp;gt;B-&amp;gt;C和A&amp;amp;#039;-&amp;gt;B&amp;amp;#039;-&amp;gt;C&amp;amp;#039;  Code 解法一 解法二 </description>
    </item>
    
    <item>
      <title>1418. 点菜展示表</title>
      <link>https://yuler.asia/topics/leetcode/1418-%E7%82%B9%E8%8F%9C%E5%B1%95%E7%A4%BA%E8%A1%A8.html</link>
      <pubDate>Tue, 06 Jul 2021 06:54:35 +0000</pubDate>
      
      <guid>https://yuler.asia/topics/leetcode/1418-%E7%82%B9%E8%8F%9C%E5%B1%95%E7%A4%BA%E8%A1%A8.html</guid>
      <description>题目地址
 Solution 重点是模拟整个流程。
golang中没有set，但可以使用map[int]struct{}来表示set，其中的value为struct{}，不会占用内存
Code 模拟 References 1. Sets in Go</description>
    </item>
    
    <item>
      <title>30. 串联所有单词的子串</title>
      <link>https://yuler.asia/topics/leetcode/30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2.html</link>
      <pubDate>Wed, 30 Jun 2021 15:42:07 +0000</pubDate>
      
      <guid>https://yuler.asia/topics/leetcode/30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2.html</guid>
      <description> 题目地址
 Solution 这题需要使用滑动窗口，需要通过words中的个数和实际窗口中的单词个数进行比较，当相同时，证明窗口字符串是由words拼接而成。问题是，单纯的比较个数二者并不绝对相等，因此在窗口扩大时，如果新加进来的right_word在窗口中的个数大于实际words中的个数，我们需要对窗口进行左移，直到二者个数相同。
因此在满足每个对应单词个数分别相同的前提下，比较所有单词个数才是有效的。
Code 哈希表+滑动窗口 Reference  https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/solution/chuan-lian-suo-you-dan-ci-de-zi-chuan-by-powcai/  </description>
    </item>
    
    <item>
      <title>126. 127. 单词接龙</title>
      <link>https://yuler.asia/topics/leetcode/126-127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.html</link>
      <pubDate>Wed, 30 Jun 2021 07:25:33 +0000</pubDate>
      
      <guid>https://yuler.asia/topics/leetcode/126-127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.html</guid>
      <description> 126 题目地址
127 题目地址
 Solution 两道题目很类似，127题要求计算最短路径大小，126题要求给出所有的最短路径
对于127题，只需要使用BFS即可，根据测试数据，1 &amp;lt;= beginWord.length &amp;lt;= 7, endWord.length == beginWord.length, 1 &amp;lt;= wordList.length &amp;lt;= 5000，我们选择遍历邻近词的个数，每次最多遍历$26\times7$次，而如果遍历wordList，则每次最多会遍历$5000\times7$次。
对于126题，需要先按照127题的思路，通过BFS构造图，然后使用DFS回溯得出最短路径
其中还有一些细节需要注意
 bfs中，在我们计算下一层的word时，当前层word对应的邻接word是可以重复的，因此我们使用了curVisited记录当前层访问过的word，当本层遍历完毕后再并到visited中 bfs中，当第一次遍历到endWord时，可以使用flag标记提前终止流程  Code 127 单词接龙i BFS 126题 单词接龙ii BFS+DFS Reference  https://leetcode-cn.com/problems/word-ladder-ii/solution/dan-ci-jie-long-ii-by-leetcode-solution/  </description>
    </item>
    
    <item>
      <title>297. 二叉树的序列化与反序列化</title>
      <link>https://yuler.asia/topics/leetcode/297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html</link>
      <pubDate>Wed, 30 Jun 2021 02:28:46 +0000</pubDate>
      
      <guid>https://yuler.asia/topics/leetcode/297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html</guid>
      <description>题目地址
 Solution  层序遍历 对于空节点，设置&amp;quot;#&amp;quot;标记 strconv.Atoi返回值类型为(int,error)  Code 层序遍历 很久没写python，手生了</description>
    </item>
    
    <item>
      <title>第247场周赛</title>
      <link>https://yuler.asia/topics/leetcode/%E7%AC%AC247%E5%9C%BA%E5%91%A8%E8%B5%9B.html</link>
      <pubDate>Sun, 27 Jun 2021 08:07:17 +0000</pubDate>
      
      <guid>https://yuler.asia/topics/leetcode/%E7%AC%AC247%E5%9C%BA%E5%91%A8%E8%B5%9B.html</guid>
      <description>1. 两个数对之间的最大乘积差  题目地址
 排序  时间复杂度：O(nlogn) 空间复杂度：O(1)  2. 循环轮转矩阵  题目地址
 模拟 next函数获的下一个坐标
注意用k对每一轮的总数进行取余
 时间复杂度：$O(MN)$ 空间复杂度：$O(MN)$  3. 最美子字符串的数目  题目地址
 我的解法(TLE) 看到的第一眼还以为是动态规划，后面发现是前缀和，不过思路还是有问题。想来对于$10^5$的数据$O(n^2)$的时间复杂度还是不够的。
使用int类型的前缀和数组维护字符状态，同时使用bitcount函数(参考题目)快速判断1的个数
 时间复杂度: $O(n^2)$ 空间复杂度: $O(n)$  前缀和+状态压缩 关于状态压缩与上面的思路相同，使用一个$10$位数字表示字符$’a’$到$’j’$的奇偶性。
对于前缀和A和前缀和B，只有其中一位的奇偶性不同或者奇偶性完全相同时，B – A之间对应的字符串才是满足要求的
对于「至多一个字母出现奇数次」，我们可以翻转当前前缀和的每个比特，然后去$cnt$数组中查找该前缀和的出现次数。
此时内循环就从$O(N)$降到了$O(K)$
 时间复杂度：$O(NK)$ 空间复杂度: $O(2^K)$   cnt := [1 &amp;lt;&amp;lt; 10]int{0: 1} prefix, ans := 0, 0 for i := 0; i &amp;lt; len(word); i++ { prefix ^= 1 &amp;lt;&amp;lt; (word[i] - �a�) ans += cnt[prefix] for j := 0; j &amp;lt; 10; j++{ ans += cnt[prefix ^ (1 &amp;lt;&amp;lt; j)] } cnt[prefix]++ } return int64(ans) }4.</description>
    </item>
    
    <item>
      <title>752.打开转盘锁</title>
      <link>https://yuler.asia/topics/leetcode/752-%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81.html</link>
      <pubDate>Sat, 26 Jun 2021 15:39:07 +0000</pubDate>
      
      <guid>https://yuler.asia/topics/leetcode/752-%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81.html</guid>
      <description> 题目地址
 Solution BFS，每次将相邻的可能出现的情况放在队列中，同时维护visited数组，注意使用两个队列
参考了题解，将时间从200ms降到20ms，关键的优化点：
 使用int数组替代map作为dead和visited 在放入队列前进行判断，而不是放到队列后 维护的数字使用int类型而非string  Code 优化前BFS 优化后BFS </description>
    </item>
    
    <item>
      <title>773. 滑动谜题</title>
      <link>https://yuler.asia/topics/leetcode/773-%E6%BB%91%E5%8A%A8%E8%B0%9C%E9%A2%98.html</link>
      <pubDate>Sat, 26 Jun 2021 15:38:20 +0000</pubDate>
      
      <guid>https://yuler.asia/topics/leetcode/773-%E6%BB%91%E5%8A%A8%E8%B0%9C%E9%A2%98.html</guid>
      <description> 题目地址
 Solution 与752. 打开转盘锁解题思路相同
 转化为字符串 判断bfs搜索下层路径生成的内容 进行bfs搜索  Code 解法一 </description>
    </item>
    
    <item>
      <title>65. 有效数字</title>
      <link>https://yuler.asia/topics/leetcode/65-%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97.html</link>
      <pubDate>Thu, 17 Jun 2021 08:26:30 +0000</pubDate>
      
      <guid>https://yuler.asia/topics/leetcode/65-%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97.html</guid>
      <description>题目地址
 Solution 真真正正的见证了这道题的进化历史————从最开始的题意含糊不清到现在的有条有理。
暴力模拟的方法非常繁琐，且很容易出错，因此往往选择使用有限状态自动机。
Code 优化前的DFA  时间复杂度：O(n) 空间复杂度：O(1)  优化后的DFA 参考题解对自动机进行了优化，减少了一个不必要的状态，状态机如图
 时间复杂度：O(n) 空间复杂度：O(1)  References 1. 表驱动法</description>
    </item>
    
    <item>
      <title>486. 预测赢家</title>
      <link>https://yuler.asia/topics/leetcode/486-%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6-2.html</link>
      <pubDate>Thu, 17 Jun 2021 06:46:45 +0000</pubDate>
      
      <guid>https://yuler.asia/topics/leetcode/486-%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6-2.html</guid>
      <description>题目地址
 Solution  数组长度为偶数时
此时奇数序列以及偶数序列两个序列中肯定有一个最大序列，而先进行选择的人能够决定选择哪一个序列，因此他是必胜的，直接返回true即可
参考问题877. 石子游戏 数组长度为奇数时
回归正常讨论。可以使用dfs自顶向下，也可以使用dp自底向上解决问题  解法一：带mem的DFS  时间复杂度：O(2^n)，每次都有头尾两个选择 空间复杂度：O(n^2)，词典空间  解法二: DP   状态定义
dp[i][j]表示，当前选手的净胜分数，无论选手是A和B，我们都让dp[i][j]尽可能地大
  递推序列
也可以参考dfs中的思路
  &amp;gt; &amp;lt;pre&amp;gt;&amp;lt;code class=&amp;quot;language-go&amp;quot;&amp;gt;sa := nums[a] - dfs(nums, a + 1, b, mem)  sb := nums[b] - dfs(nums, a, b - 1, mem) mem[a][b] = max(sa, sb)&amp;gt; &amp;gt; dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1])
填表方向(需要满足i &amp;lt; j)  &amp;lt;th style=&amp;quot;text-align: center;&amp;quot;&amp;gt; &amp;lt;/th&amp;gt; &amp;lt;th style=&amp;quot;text-align: center;&amp;quot;&amp;gt; 1 &amp;lt;/th&amp;gt; &amp;lt;th style=&amp;quot;text-align: center;&amp;quot;&amp;gt; 2 &amp;lt;/th&amp;gt;  &amp;lt;td style=&amp;quot;text-align: center;&amp;quot;&amp;gt; →↑ &amp;lt;/td&amp;gt; &amp;lt;td style=&amp;quot;text-align: center;&amp;quot;&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td style=&amp;quot;text-align: center;&amp;quot;&amp;gt; &amp;lt;/td&amp;gt;  &amp;lt;td style=&amp;quot;text-align: center;&amp;quot;&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td style=&amp;quot;text-align: center;&amp;quot;&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td style=&amp;quot;text-align: center;&amp;quot;&amp;gt; &amp;lt;/td&amp;gt;  &amp;lt;td style=&amp;quot;text-align: center;&amp;quot;&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td style=&amp;quot;text-align: center;&amp;quot;&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td style=&amp;quot;text-align: center;&amp;quot;&amp;gt; &amp;lt;/td&amp;gt;  从下至上，从左至右，</description>
    </item>
    
    <item>
      <title>852. 山脉数组的峰顶索引</title>
      <link>https://yuler.asia/topics/leetcode/852-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95.html</link>
      <pubDate>Tue, 15 Jun 2021 02:05:20 +0000</pubDate>
      
      <guid>https://yuler.asia/topics/leetcode/852-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95.html</guid>
      <description> 题目地址
 Solution 使用二分法来加速查找，以达到O(n)的时间复杂度。判断的条件是arr[mid] &amp;gt; arr[mid + 1]，需要注意边界控制。
code  时间复杂度：O(log(n)) 空间复杂度：O(1)  </description>
    </item>
    
    <item>
      <title>374. 猜数字大小</title>
      <link>https://yuler.asia/topics/leetcode/374-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F.html</link>
      <pubDate>Mon, 14 Jun 2021 15:05:29 +0000</pubDate>
      
      <guid>https://yuler.asia/topics/leetcode/374-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F.html</guid>
      <description> 题目地址
 Solution 很简单的二分法，直接上代码
code </description>
    </item>
    
  </channel>
</rss>
