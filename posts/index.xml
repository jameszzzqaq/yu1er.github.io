<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on yuler&#39;s blog</title>
    <link>https://zhangyh.me/posts/</link>
    <description>Recent content in Posts on yuler&#39;s blog</description>
    <image>
      <url>https://zhangyh.me/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://zhangyh.me/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 15 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://zhangyh.me/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>单调栈题集</title>
      <link>https://zhangyh.me/posts/leetcode/monotone-stack/</link>
      <pubDate>Fri, 15 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/leetcode/monotone-stack/</guid>
      <description>单调栈 单调栈可以保证栈内元素线性有序,同时复杂度为$O(n)$.
通常的trick会在首尾处添加两个哨兵元素.
题目 84. 柱状图中最大的矩形 很经典的单调栈用法.
class Solution { public: int largestRectangleArea(vector&amp;lt;int&amp;gt;&amp;amp; heights) { vector&amp;lt;int&amp;gt; nums(heights.size() + 2); copy(begin(heights), end(heights), begin(nums) + 1); int n = nums.size(); stack&amp;lt;int&amp;gt; stk; stk.push(0); int ans = 0; for (int i = 1; i &amp;lt; n; i++) { while (nums[i] &amp;lt; nums[stk.top()]) { int h = nums[stk.top()]; stk.pop(); int w = i - stk.top() - 1; ans = max(ans, h * w); } stk.</description>
    </item>
    
    <item>
      <title>cpp问题清单</title>
      <link>https://zhangyh.me/posts/cpp/problem-list/</link>
      <pubDate>Sun, 10 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/cpp/problem-list/</guid>
      <description>问题1 #include &amp;lt;iostream&amp;gt; class A { public: virtual void func(int val = 1) {std::cout &amp;lt;&amp;lt; &amp;#34;A-&amp;gt;&amp;#34; &amp;lt;&amp;lt; val &amp;lt;&amp;lt; std::endl; } virtual void test(){func();} }; class B : public A { public: void func(int val = 0) {std::cout &amp;lt;&amp;lt; &amp;#34;B-&amp;gt;&amp;#34; &amp;lt;&amp;lt; val &amp;lt;&amp;lt; std::endl;} }; int main () { B* b = new B; b-&amp;gt;test(); return 0; } 输出  B-&amp;gt;1
 解释 参考《Effective c++》条款37: 绝不重新定义继承而来的缺省默认值. 因为虚函数是动态绑定,因此b实际指向的就是b.而默认参数是静态绑定,是由编译器决定的.
 test函数是A的,test内部调用func实际上是this-&amp;gt;func,func是个虚函数而且在B中被重写了,所以有动态绑定. 这里的this运行时类型是B,所以调用B的func,但是缺省参数实际上是静态绑定的,所以输出的val是A中的那个val.</description>
    </item>
    
    <item>
      <title>priority_queue自定义排序</title>
      <link>https://zhangyh.me/posts/cpp/priority-queue-custom-comparator/</link>
      <pubDate>Thu, 07 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/cpp/priority-queue-custom-comparator/</guid>
      <description>给定一个pair&amp;lt;int, int&amp;gt;数组,通过自定义排序顺序决定优先队列中的顺序.
vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; nums{{4, 1}, {8, 2}, {1, 9}, {8, 1}, {8, 4}, {3, 7}}; 仿函数 (推荐) 仿函数的出现就是为了解决函数指针在作为函数参数向函数传递时的局限性问题. 通过重写类的operator(),使该类具有函数的功能.
struct cmp { bool operator() (const pair&amp;lt;int, int&amp;gt; &amp;amp;a, const pair&amp;lt;int, int&amp;gt; &amp;amp;b) { return a.first == b.first? a.second &amp;lt; b.second : a.first &amp;lt; b.first; } }; priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, cmp&amp;gt; pq; lambda 通过c++11新特性的lambda和delctype,可以避免重新定义类. 但需要注意,lambda函数需要通过构造函数的参数传递.
auto a = [](const pair&amp;lt;int, int&amp;gt; &amp;amp; a, const pair&amp;lt;int, int&amp;gt; &amp;amp;b){ return a.first == b.</description>
    </item>
    
    <item>
      <title>FloDB: Unlocking Memory in Persistent Key-Value Stores</title>
      <link>https://zhangyh.me/posts/paper/sep/flodb/</link>
      <pubDate>Sun, 26 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/paper/sep/flodb/</guid>
      <description>Shortcomings of current LSMs   线程的可扩展性 LevelDB允许一定程度的并发写，但内部是将写入操作写到了一个队列中，最后仍是顺序执行。 HyperLevelDB、RocksDB、cLSM做了一定程度的并行优化
  内存的可扩展性 内存中组件可以是有序跳表，也可以是无序哈希表，但二者都不适合应用到更大的内存中。 对于跳表而言，读写时间复杂度都是$O(logn)$，有序性一定程度优化了范围查询，并加速了flush过程。但一般来说，读取操作都要到达磁盘，因此，跳表对写入的负面影响大于对读取的正面影响。对于更大内存中更大的跳表，读写延迟往往会提高。 对于哈希表而言，读写时间复杂度都是$O(1)$，无序性增加了范围查询和flush过程的工作量。但哈希表需要更长的时间排序，size越大，所需时间越长，会阻塞上层的写入操作。
  FloDB Design 设计了两层的内存组件，上层是small、fast、unordered的Membuffer，下层是larger、ordered的Memtable。两层都是可并行的数据结构，数据流跟LSM类似，从最小的Membuffer，流向Memtable，直到磁盘上的SStable。
Get 搜索顺序：Membuffer -&amp;gt; Memtable -&amp;gt; SStable
Update Put和Delete操作和Update是相似的。 首先尝试在Membuffer更新，如果Membuffer满了，就直接在Memtable上完成更新。（假如说Membuffer或Memtable上有对应值的话，更新就是in-place的）
替代的方案就是mulit-version更新，然而对比起来，in-place更新在skewed的工作负载上具有更好的表现。
Scan 扫描Memtable和disk，同时允许Membuffer进行并行的update。 挑战1：Membuffer有对应的数据，因此扫描前先清空Membuffer到Memtable上。 挑战2：long-time的扫描导致Membuffer变满，允许writer和sanner在Memtable上并行。这个时候可能会导致不一致性，因此我们记录scan时的sequence number，扫描后的结果中如果有大于该值的entry，则重新扫描。
FloDB Implementation 明确了四各方面:
 Membuffer和Memtable数据结构的选择 数据从Membuffer到Memtable移动的机制 新颖的多插入操作用于简化 Memtable 和 Membuffer 之间的数据流 面向用户的操作的实现  Memory Component Implementation Membuffer -&amp;gt; Hash Table Memtable -&amp;gt; Skiplist
Interaction Between Levels 包括persisting和draining.
Skiplist Multi-inserts 实验显示，多线程下hash table比skiplist块一到两个数量级。因此应该尽快地完成移动，使得update在hash table上进行。
批量的插入多个kv对到skiplist中，而不是挨个插入。核心思想是我们能直接利用前一个kv对的pre指针，而不是重新找，有path-reuse的思想在里面。
并行性。插入和insert、read并行。
key的临近度决定了path-reuse的效果。</description>
    </item>
    
    <item>
      <title>SFM: Mitigating Read/Write Amplification Problem of LSM-Tree-Based Key-Value Stores</title>
      <link>https://zhangyh.me/posts/paper/sep/sfm/</link>
      <pubDate>Fri, 24 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/paper/sep/sfm/</guid>
      <description>Movitation  传统的merge policy  Level Merge Policy和Tiered Merge Policy在读写放大方面各有优势. 前者相当于单层的Tiered,保证了单层数据的有序性,减少了读放大,但要维护这种有序性,就需要频繁的merge,因此造成了严重的写放大. 后者对有序性的要求并不严格,它只要求每个group的key range互不交叉,允许sstable之间的key交叉.
工作负载的空间局部性  作者对ZippyDB(facebook)的工作负载分析发现,少部分的key被读写多次,大部分的key被读写的次数很少.
Design 作者提出了疑问:
 How to resolve the read amplification problem induced by the tiering merge policy while maintaining its low write amplification?
 根据key-space的不同access pattern,有选择的采用Tiering和Leveling Merge policy. 通过追踪每层中的key-space的访问强度,来决定设置T的值为1还是configured threshold.
Spatially Fragmented LSM-TREE (SFM) 每层通过随机的边界分为不同的key-space.边界的选取方式类似于PebblesDB. 如果一个栈的key-range被认为是读密集的,则设置T为1,否则,按照原有的配置设置.
合并策略如上图
 读超过stack阈值的文件到内存 在内存中进行merge 按照下层的key边界进行切片 新SSTable被刷新到下层 添加到key对应的栈  B. Read Intensity Identification 如何判断读的强度呢? 统计每个段的读写次数.对于读操作,即使读取的key不存在,也是要计入读取次数的. 对于写操作,统计每次merge后的sstable中的kv对的数量. 通过对比每个stack的r/w和整体平均的r/w来判断其为hot还是cold. 根据每个stack的hot还是cold属性,来决定key-space的访问强度.
Metadata Managment 通过StackMetadata的数据结构来管理每个stack的元信息.</description>
    </item>
    
    <item>
      <title>SILK: Preventing Latency Spikes in Log-Structured Merge Key-Value Stores </title>
      <link>https://zhangyh.me/posts/paper/sep/silk/</link>
      <pubDate>Wed, 22 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/paper/sep/silk/</guid>
      <description>本文旨在解决LSM-Tree的长尾问题，长尾问题的根源主要是客户端操作和LSM-Tree内部操作的互相干扰。 客户端操作：write 内部操作: flush、compaction
Experiment study of tail latency  实验一：对比RocksDB和RocksDB without flushing. RocksDB without flushing: 要flush的immutable memtable直接丢弃 实验二：Rate-limited RocksDB 实验三：RocksDB with increased Memtable 实验四：TRAID 实验五：PebblesDB  作者对目前最新的LSM-Tree数据库RocksDB、TRIAD、PebblesDB进行了实验并得出三点结论。
 长尾的主要原因是被写满的memtable阻塞了write。 有两个原因导致了这种情况：第一，磁盘上的L0-L1 compaction跟不上写入的速度，导致L0被写满。第二，意外的有大量的compaction在同时进行，占据了大量的IO，导致flush因为有限的带宽而变慢，使得memtable变满。 简单的限制内部操作带宽, 并不能解决flush带宽受限的问题，长远来看反而会加剧这种问题。这种方法能够推迟压缩，但增加了在未来某个时候同时发生compaction的可能性。 提高吞吐量的方法，例如选择性地启动压缩或仅在最高level执行压缩，在短期内避免了延迟峰值，但从长远来看会加剧问题，因为它们也会增加在稍后的某个时间点进行许多并发压缩的可能性。  推论： 由1得出推论：内部操作并不是完全平等的。更low-level的操作是关键的，因为未能及时完成它们可能会导致客户端操作停滞。 由2，3得出推论：必须进行长时间的测试，避免问题未被发现。 (因为写入的数据量不够的话，无法体现更底层的compaction操作对系统的影响。)
SILK Design principles  有选择的分配带宽。 遇到峰值流量时，分配更多的带宽给low-level，减缓high-level的压缩。 在闲时，利用短暂的低负载时期来促进内部操作的处理 优先处理更low-level的操作 给内部操作指定优先级: flush &amp;gt; L0-L1 compaction &amp;gt; high-level compaction 抢占式compaction 允许更low-level的compaction抢占high-level的compaction  Implementation  有选择的分配带宽 有优先次序和可抢占的内部操作 系统内部维护两个线程池：高优先级池用于flush,低优先级池用于compaction.   Flush: 有专门的线程池，在mem被写满之前，提供稳定的一定量的带宽，以保证不断的写入。多个内存组件和多个线程可能保证较长的性能高峰。 L0-L1 compaction: 和high-level的compaction共用线程，该过程需要保证L0有足够的空间供flush。如果需要进行L0-L1的compaction，并且目前没有可用线程，那么就会抢占high-leve compaction的线程。 high-level compaction: 线程维护在低优先级线程池  </description>
    </item>
    
    <item>
      <title>weekly-contest-259</title>
      <link>https://zhangyh.me/posts/leetcode/weekly-contest-259/</link>
      <pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/leetcode/weekly-contest-259/</guid>
      <description>第259次周赛 A. 执行操作后的变量值  时间复杂度: $O(n)$ 空间复杂度: $O(1)$  class Solution { public: int finalValueAfterOperations(vector&amp;lt;string&amp;gt;&amp;amp; operations) { int X = 0; for (auto &amp;amp; s: operations) { if (s[1] == &amp;#39;+&amp;#39;) X++; else X--; } return X; } }; B. 数组美丽值求和 通过正反两次遍历记录每个值左边的最大值和右边的最小值.
 时间复杂度: $O(n)$ 空间复杂度: $O(n)$  class Solution { public: int sumOfBeauties(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); vector&amp;lt;int&amp;gt; left(n, INT_MIN), right(n, INT_MAX); int ans = 0; left[0] = nums[0]; right[n - 1] = nums[n - 1]; for (int i = 1; i &amp;lt; n; i++) left[i] = max(left[i-1], nums[i]); for (int i = n - 2; i &amp;gt;= 0; i--) right[i] = min(right[i + 1], nums[i]); for (int i = 1; i &amp;lt; n - 1; i++) { if (left[i - 1] &amp;lt; nums[i] &amp;amp;&amp;amp; nums[i] &amp;lt; right[i + 1]) ans +=2; else if (nums[i - 1] &amp;lt; nums[i] &amp;amp;&amp;amp; nums[i] &amp;lt; nums[i + 1]) ans++; } return ans; } }; C.</description>
    </item>
    
    <item>
      <title>biweekly-contest-61</title>
      <link>https://zhangyh.me/posts/leetcode/biweekly-contest-61/</link>
      <pubDate>Sun, 19 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/leetcode/biweekly-contest-61/</guid>
      <description>第61次双周赛 A: 差的绝对值为 K 的数对数目  时间复杂度:$O(n)$ 空间复杂度:$O(n)$  class Solution { public: int countKDifference(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { map&amp;lt;int, int&amp;gt; m; int ans; for (auto &amp;amp;&amp;amp; x : nums) { ans += (m[x + k] + m[x - k]); m[x]++; } return ans; } }; B: 从双倍数组中还原原数组 两个关键点: 1. 元素个数一定为偶数 2. 结果数组元素个数一定是原数组二分之一
 时间复杂度: 排序: $O(nlgn)$ 遍历: $O(n)$ 空间复杂度: $O(n)$  class Solution { public: vector&amp;lt;int&amp;gt; findOriginalArray(vector&amp;lt;int&amp;gt;&amp;amp; changed) { auto n = changed.</description>
    </item>
    
    <item>
      <title>The Google File System</title>
      <link>https://zhangyh.me/posts/paper/aug/gfs/</link>
      <pubDate>Sat, 28 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/paper/aug/gfs/</guid>
      <description>1 Introduction 本文是《The Google File System》的学习笔记
2 Design Overview 2.1 Assumptions GFS基于以下基本假设作为设计原则。
 廉价商用机器出故障是常态 主要存储大文件，通常大于100MB，没有针对小文件的优化 读操作：大规模的流式读、小规模的随机读 写操作：大规模的append写操作、小规模的随机写效率低 支持多个客户端并行 append 到同一个文件 持续的高带宽比低时延重要  2.2 Interface  未实现POSIX API 支持常见文件操作，包括create, delete, open, close, read, write. 包括 snapshot 和 record append  2.3 Architecture  集群通常包括一个 master、多个 chunkserver 和多个访问的 client 文件使用固定大小(64 MB)的 chunk 存储，使用globally unique、immutable的 64bit chunk handle表示 master 维护整个集群所有的 metadata ，通过 heartbeat 与 chunkserve 进行 instruct、state-collect client 以 lib 的形式嵌入到应用中，以供 application 调用 client 和 chunkserver 都不 cache file data，但 client 会 cache metadata  2.</description>
    </item>
    
    <item>
      <title>聊聊内存对齐</title>
      <link>https://zhangyh.me/posts/misc/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</link>
      <pubDate>Fri, 13 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/misc/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</guid>
      <description>为什么需要内存对齐？ 首先需要从物理硬件上了解计算机如何进行内存访问的。
 Channel &amp;gt; DIMM &amp;gt; Rank &amp;gt; Chip &amp;gt; Bank &amp;gt; Coloum/Row &amp;gt; Cell
 如上图 CPU包括两个Channel 每个Channel包括两个DIMM 每个DIMM由Rank组成 Rank由8个内存颗粒chip组成 每个Chip包括8个Bank
CPU读取内存时从8个chip中每个读取8bit字节，从而构成64bit column和row定位的一个单元格cell中有8个bit
因此一次性最少读取64bit，这恰好也是cacheline的大小。 （cacheline是cache的基本单位，每个cache由若干cacheline组成）
什么是内存对齐 从上面我们可以知道，一次性最少读取8B，这也是局部性原理的一种使用。
内存对齐就是代码编译后在内存中的布局，当一个内存地址刚好能够整除8，就称为其内存地址是8字节对齐的。
为什么需要内存对齐 对于go中定义的如下结构
type Type1 struct { a int8 b int64 c int32 } 其内存布局是这样的： 通过unsafe.Sizeof()可以打印出该结构占用了24字节的内存。
如果调整一下顺序：
type Type2 struct { a int8 c int32 b int64 } 便可以节约一个字节的内存
零大小字段 如果结构体或数组类型不包含大小大于零的字段或元素，那么它的大小就为0
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;unsafe&amp;#34; ) type M struct { m int64 x struct{} } type N struct { x struct{} n int64 } func main() { m, n := M{}, N{} fmt.</description>
    </item>
    
    <item>
      <title>LSM-based storage techniques: a survey</title>
      <link>https://zhangyh.me/posts/paper/aug/suvery-of-lsm/</link>
      <pubDate>Tue, 10 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/paper/aug/suvery-of-lsm/</guid>
      <description> paper原文：LSM-based storage techniques: a survey
 LSM-tree basics 对于索引结构通常有两种更新策略，即in-place update和out-of-place update。
in-place通常使用B+树作为底层数据结构，通过随机写来更新数据项，带来的是读数据的优化，同时每个数据项只存有一份，因此节约了空间。
out-place通常使用lsm tree作为底层数据结构，将随机写转化为顺序写，加快了写的速度，但同时降低了读数据的性能，另外，对同一个key，存有多个版本，带来了空间上的浪费。
LevelDB是谷歌开源的kv数据库，它基于内存-磁盘的存储层次，实现了LSM Tree最基本的功能。 内存中有memtable，使用skiplist来按顺序存储kv对 磁盘中有分层的sstable，使用sorted-string table以文件的形式来存储。 sstable包括了data block、index block、footer block
如今的lsm tree通常为了加快读速度，往往会具有bloom filter组件，该组件有两个操作：插入key和检查key是否存在。为磁盘中的每一level，维护一个bloom filter，从而提高读性能。需要注意，它是false positive的。 同时因为该结构比较小，往往把他缓存到内存当中。
对于failure recovery，使用WAL保证内存中memtable的recovery，使用manifest保证merge过程中sstable的recovery。
有两种常用的merge policy，如上图所示。 Leveling merge policy，要求每一层的SSTable之间不能overlap，merge的时候将第i层的SSTable和第i+1层overlape的所有SSTables进行merge，然后写入i+1层。也就是说通过leveling通过频繁的merge，使得每一层全部有序，牺牲部分写性能来换取读性能。
Tiering merge policy，要求每一层的SSTable之间可以overlap，在sstable达到一定的数量或者size要求后，对该层所有的SSTable进行merge sort，然后直接flush进下一层。该策略通过减少merge操作，牺牲部分读性能换取了写性能。
LSM-tree improvement 文章将对LSM-tree的优化分为以下几个方面：
 Write Amplification: out-of-place数据结构所具有的问题，降低了写性能和磁盘寿命。 Merge Operation: merge后会造成buffer cache miss，大数据量的merge会造成write stall Hardware: 针对large memory,multi-core, SSD/NVM, native storage的优化 Special Workloads: Auto-tuning: 不可能同时达到read,write,space同时最优，并且由于lsm tree拥有大量参数，手动调优也是困难的。 Secondary Indexing: lsm tree只支持简单的kv接口，二级索引也是一个方向。  </description>
    </item>
    
    <item>
      <title>Wisckey: Separating keys from values in ssd-conscious storage</title>
      <link>https://zhangyh.me/posts/paper/aug/wisckey/</link>
      <pubDate>Tue, 10 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/paper/aug/wisckey/</guid>
      <description>WiscKey Design Goals  Low写放大 Low读放大 SSD优化 Feature-rich API (scan、snapshot) Realistic k-v size (value的size通常比key的大很多)  K-V Separation  LSM tree的主要性能成本在于Compaction，但它维护了key的有序性，对于加速读也是十分有必要的。 Compaction只需要对key排序，因此考虑将k-v分开存储。只把value的地址和key放在一起。  LSM tree的size将大大变小，减少了写放大。 读操作虽然需要一次额外的寻址操作，但更小的LSM tree加快了检索同时更容易缓存到大内存中。    Challenge   Parallel Range Query 在levelDB中，范围查询通过iterator的顺序读实现，但是现在由于和key一同存储的只有value的地址，范围查询变为了随机io。 我们在读取所有的地址后，写入一个队列，通过多线程并发读取，来加快范围查询的性能。
  Garbage Collection 由于把所有的数据都存到了vLog里，最朴素的垃圾回收的方法当然是扫描一遍LSM-tree，但开销太大了，只适用于离线环境。 WiscKey在vlog中存储(ksize, vsize, key, value)，并维护head和tail指针。   数据在head处添加 垃圾回收线程从tail处扫描，每次扫描一定量的数据（几MB），然后在LSM-tree中查找，如果kv对有效的话，则再把它添加到head处。 因此，只有tail和head之间的数据是有效的。
Crash Consistency  Optimizations  Value-Log Write Buffer  对于写密集的数据集，频繁的大量的小size的value写入，会导致较大的系统开销。 因此考虑在内存中维护Buffer。 当读数据的时候，先到vlog write buffer中查找，如果没有，再查vlog。 crash-consistency的维护类似于levelDB，使用WAL。
Optimizing the LSM-tree Log  在写LSM-tree之前需要先写vlog，因为这里我们加了vlog write buffer，所以我们直接用vlog的日志作为WAL。</description>
    </item>
    
    <item>
      <title>Hashkv: Enabling efficient updates in KV storage via hashing</title>
      <link>https://zhangyh.me/topics/paper/hashkv.html</link>
      <pubDate>Sat, 07 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/topics/paper/hashkv.html</guid>
      <description>Hashkv: Enabling efficient updates in KV storage via hashing Introduction kv分离的Wisckey在vLog的GC上有着以下的问题：
 最新写入的数据被从tail迁移到head处，带来了写放大。 每次GC，对于每一项都需要去查询LSM-Tree，去验证是否还有效，造成大量随机读  Design Storage Management 固定大小的空间单元main segment和log segment。 默认分别为64MB和1MB.
segment group 包括一个main segment和多个log segment.
内存中全局的segment table存储每一个segment group接下来插入或更新的位置。
为了方便GC，segment group存储了key/value size，key，value
GC Collection GC以segment group为单元，当free log segment用尽的时候会触发。
 首先选择候选的segment group，并识别valid KV 然后将valid KV写新的main segment和log segment 再释放之前未使用的log segment 最后更新LSM-Tree中value的最新位置  两个问题：
 如何选择候选的segment group? 根据更新的kv数量，快速选择 如何快速验证KV时valid的 从尾部第一次读到的key，它对应的kv一定是最新的。  Hotness Awareness 在对segment group进行GC后，决定其中数据项为hot还是code。
hot数据仍然写回segment group. code数据写到另外一个区域，旨在segment group中保留其metadata()
如何判断冷热？ 在最后插入后，又更新过一次的即为热数据。
我们称呼该过程为tagging，注意，tagging只发生在GC时。</description>
    </item>
    
    <item>
      <title>A Light-weight Compaction Tree to Reduce I/O Amplification toward Efficient Key-Value Stores</title>
      <link>https://zhangyh.me/posts/paper/aug/lwc-tree/</link>
      <pubDate>Fri, 06 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/paper/aug/lwc-tree/</guid>
      <description>A Light-weight Compaction Tree to Reduce I/O Amplification toward Efficient Key-Value Stores Introduction 一般情况下的LSM Tree写放大能达到50X倍 缓解写放大的方法可能有以下几种：
 使用更大的内存buffer 利用设备的特性 逐步散列 KV 项 减少level层级 减少每层的空间放大因子  Design light-weight compaction 也是借鉴了wisckey中提到的，merge and sort过程只是面向key的，不需要value的参与 在对Level i 和 Level i+1进行compaction时，我们把第i层的候选的sstable成为victim，把与victim有overlap的i+1层的sstable成为overlaped. (注意该论文为sstable设计了另外一种存储格式，成为DTable) 因此整个lightweight compaction过程为:
 读取victim到内存中，victim包括了overlaped的metadata 然后根据metadata，将victim分为几个segment 再根据key range将segment追加到对应的DTable中  victim一层的写放大被消除了，随之带来的问题就是DTable的读，虽然每一层的DTable之间是无overlap且有序的，但是DTable内的key值并不是完全有序的。
降低了大概10X的写放大.
Metadata Aggregation overlaped的元数据如何获取。 直觉的方法是直接从overlaped读，但这带来的随机io违背了我们的设计初衷。 另一种是直接在内存中缓存元数据，但这部分开销并不算小，并不划算 为了解决这个问题，我们提出了元数据聚合。 在一次compaction完成后，第i+1层被更新的元数据存储到victim中，以此避免下一次compaction时对metadata的访问呢。
通过compaction过程中一次额外的写，减少AF倍的i+1层的随机读。
Data structure of DTable 每个DTable维护下层的overlaped Dtables metadata 每次compaction过程中append进来的数据作为一个segment,segment之间的key是overlap的,会导致查找性能的下降 MetadaBlock包括了bloom filter blocks,overlaped metada_index block, metada_index block,index block footer</description>
    </item>
    
    <item>
      <title>An Empirical Guide to the Behavior and Use of Scalable Persistent Memory</title>
      <link>https://zhangyh.me/posts/paper/aug/optane/</link>
      <pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/paper/aug/optane/</guid>
      <description>Introduction 过去的很多研究都是基于仿真模拟的NVM，他们基于——NVM表现和DRAM类似，只不过性能相对较低——这样的假设完成了研究。
但实验发现，Optane DIMM的性能与DRAM相比，更依赖于
 access size access method(read,write) pattern degree of concurrency  本文通过经过实验证明了之前的很多仿真方法都是不可靠的。
Background Optane DIMM是第一款商用NVDIMM 与SSD/HDD相比，它low latency、higher read bandwidth、byte-address 与DRAM相比，它higher density、persistent
Optane Memory Optane DIMM使用和DRAM相同的插槽，和处理器的集成内存控制器（iMC)相连接。Intel Cascade Lake处理器是第一个支持Optane DIMM的处理器，有一个或两个processor die，每个die支持两个iMC，每个iMC支持三个channel，因此一个die可以支持6个Optane DIMM
为了持久化，iMC维护一个asynchronous DRAM refresh(ADR)区域，写入这个区域内的数据都能保证其被持久化。ADR区域不保证处理器cache的持久化。
iMC按照缓存行粒度(64byte)和Optane DIMM通信。
Optane DIMM中
3D-XPoint物理介质的访问粒度为256byte，因此会造成写放大，所以会在XPController中有controller负责将小于256B的操作变成256B的访问，同时内部有Buffer用来合并临近的访问。
为了磨损均匀、坏块的管理，AIT用于进行内部地址转换。
Operation Model Optane DIMM有两种模式Memory和App Direct
 Memory Model 该模式下直接将Optane DIMM作为普通的内存使用，将DRAM作为内存的Cache，DRAM是透明的，直接观察到的内存容量就是Optane DIMM的容量。 该模式可以解决一些内存数据库内存容量不足的问题。 App Direct Model 该模式将Optane DIMM作为持久化设备使用，直接通过CPU指令读写。文件系统和其他的管理层管理持久化内存的分配、回收和访问。  支持交错访问，最小的单位是4KB，保证一个page一定是从一个DIMM中读取出来的
ISA Support store: 绕过store buffer ntstore: 绕过CPU cache，直接写到内存。一般用于写完就不管的情况，可以防止污染cache。 clflush: 把cache line刷回内存，并且让cache line失效。只能串行执行。 clflushopt: 功能同clflush，但是不同缓存行可以并发执行。 clwb: 除了写回后不让cache line失效，其他同clflushopt。 sfence：写屏障，在sfence指令前的写操作当必须在sfence指令后的写操作前完成</description>
    </item>
    
    <item>
      <title>Redesigning LSMs for nonvolatile memory with NoveLSM</title>
      <link>https://zhangyh.me/topics/paper/novelsm.html</link>
      <pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/topics/paper/novelsm.html</guid>
      <description>Introduction 和目前的存储技术（例如flash、硬盘）相比， NVM有着以下的没有被LSM考虑的优点：
 对于持久存储的随机访问的高性能 in-place update的低成本 (具体是?) 低时延、高带宽为application-level的并行化提供了机会  作者认为探索redesign适用于NVM的LSM是有意义的，而不是design a new data structure。 基于以下考量：
 未来几年NVM和SSD共存，形成异质存储，而不是完全取代。redesign LSM可以在利用NVM的优点的前提下，同时不失去ssd和硬盘最优化的优势。 redesign lsm能为现有的应用提供向后兼容 保证批量写入NVM同样重要（NVM写延迟为DRAM的5-10倍）  Motivation 单纯的硬件NVM的读写是SSD的100倍左右，但在LevelDB在NVM和SSD上的差异只有4-7倍 因此可以说目前的LSM没有充分利用NVM的硬件优势，软件开销较大
Insert Latency insert latency来源有三个方面：
 WAL memtable insert compaction   对于compaction 内存中的mutable memtable在写满之后会刷新成immutable memtable，由后台进程将其压缩进磁盘，同时新开一个mutable memtable，来接管写入 问题是新的mutable memtable写满之后，如果immutable memtable还没有刷到磁盘内，就会造成系统的停顿 当进行大量的写入时，这会成为insert latency的主要来源。
 可能会说，让memtable大一点不就可以解决，但这会带来一系列的问题：
 增大memtable会带来双倍的内存占用，因为mutable memtable和immutable memtable需要同时增大 WAL的磁盘占用也会更大，因为他需要容纳更多的指令 LSM为了性能并不commit log。   Third, LSMs suchas LevelDB and RocksDB do not enforce commits (sync) when writing to a log; as a result, an application crash or power-failure could lead to data loss</description>
    </item>
    
    <item>
      <title>Zen: a high-throughput log-free OLTP engine for non-volatile main memory</title>
      <link>https://zhangyh.me/posts/paper/aug/zen/</link>
      <pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/paper/aug/zen/</guid>
      <description>Design Overview  Hybrid Table(HTable)  tuple heap in NVM Met-Cache in DRAM per-thread NVM-tuple managers.   Metadata in NVM Transaction and Indices in DRAM  NVM heap 所有的tuple持久化到NVM中的tuple heap，它由大小为2MB的pages组成 其中可能同时存在某个数据的多个版本 (tupleId, Tx-CTS)唯一确定一个tuple
 LP: 在commited transaction中最后一个被持久化的tuple，将该标记记为1 Tx-CTS: 每个事务在线程内都有唯一ID，单调递增。 Deleted: 被删除  Met-Cache NVM heap在DRAM中的缓存
 Clock bit: 用于Clock置换策略 Active bit: 事务正在使用该tuple Dirty bit: 被修改，当事务中途被absort，根据dirty位重新到NVM Heap获取tuple Copy bit: tuple被复制 CC-Meta：用于DRAM中的并发控制时，存储对应的信息。Zen中的并发控制完全实现在DRAM中，支持多种并发控制策略。  Indices in DRAM 在DRAM维护索引。crash后会重建。索引指向Met-Cache或者NVM heap中的tuple
Transaction-Private Data 线程私有 用于事务并发访问 存储相应数据</description>
    </item>
    
    <item>
      <title>Go | 内存分配</title>
      <link>https://zhangyh.me/posts/golang/go-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</link>
      <pubDate>Sat, 17 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/golang/go-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</guid>
      <description>Go | 内存分配 设计原理 Go的内存分配参考了TCMalloc的核心思想。
 每一个线程都可以获得一个用于无锁分配小对象的缓存，这样可以让并行程序分配小对象（&amp;lt;=32KB）非常高效。 TCMalloc 管理的堆由一组页组成，一组连续的页面被表示为 span。当分配的对象大于 32KB，将使用页堆（Page Heap）进行内存分配。  相关struct mspan mspan是Go语言内存管理的基本单元。
type mspan struct { next *mspan // 链表指针 	prev *mspan // 链表指针  startAddr uintptr // span 起始地址 	npages uintptr // page的数量  spanclass spanClass // size class and noscan (uint8) 	state mSpanStateBox // span状态 	limit uintptr // end of data in span } 这里只列出了关心的主要字段。
 mspan使用 next和prev指针构成双向链表 startAddr确定了mspan所在内存的地址，npages确定了内存地址范围 每个mspan都管理这npages数量的page（注意这里的page不是操作系统的page，它是操作系统page的整数倍） state为mspan的状态，不细说。  spanClass 这是mspan中一个很核心的字段，spanClass是跨度类，它决定了mspan中管理的存储对象的大小和个数。</description>
    </item>
    
    <item>
      <title>Go | context</title>
      <link>https://zhangyh.me/posts/golang/go-context/</link>
      <pubDate>Fri, 16 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/golang/go-context/</guid>
      <description>Go | context 什么是context context 主要用来在goroutine之间传递上下文信息，包括：取消信号、超时时间、截止时间、k-v 等。
可以通过以下个函数创建实现对应的功能:
 context.WithCancel(): 创建带有取消函数的context，上层goroutine调用cancelFunc函数，向下层传递取消信号 context.WithTimeout(): 创建带有超时的context，同时创建计时器，超时的时候调用context的cancelFunc；当然也可以主动调用cacelFunc context.WithDeadline(): 和带超时的context类似，实际底层WithTimeout就调用了WithDeadline； return WithDeadline(parent, time.Now().Add(timeout)) context.WithValue(): 创建带值的context  使用场景 1. 链路传值 func Test1() { ctx := context.WithValue(context.Background(), &amp;#34;key&amp;#34;, &amp;#34;value&amp;#34;) go handleChainA1(ctx) go handleChainA2(ctx) time.Sleep(2 * time.Second) } func handleChainA1(ctx context.Context) { log.Println(&amp;#34;handleChainA1&amp;#34;, ctx.Value(&amp;#34;key&amp;#34;)) go handleChainB(context.WithValue(ctx, &amp;#34;key2&amp;#34;, &amp;#34;value2&amp;#34;)) } func handleChainA2(ctx context.Context) { log.Println(&amp;#34;handleChainA2&amp;#34;, ctx.Value(&amp;#34;key&amp;#34;)) } func handleChainB(ctx context.Context) { log.Println(&amp;#34;handleChainB&amp;#34;, ctx.Value(&amp;#34;key&amp;#34;)) log.Println(&amp;#34;handleChainB&amp;#34;, ctx.Value(&amp;#34;key2&amp;#34;)) } func main() { Test1()	}  注意值的流向只能从上到下，上层context是获取不到下层传入的值的 传入的context不能为nil，可以传context.</description>
    </item>
    
    <item>
      <title>Go | make和new</title>
      <link>https://zhangyh.me/posts/golang/go-make%E5%92%8Cnew/</link>
      <pubDate>Sun, 11 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/golang/go-make%E5%92%8Cnew/</guid>
      <description>区别    方法 作用对象 返回值     new 值类型和用户定义类型 指向对象的指针   make 内置引用类型slice, map, channel 引用类型本身     值类型: 引用类型：
 new new用于为值类型或用户自定义的类型分配内存，并初始化零值，返回零值指针。
package main import ( &amp;#34;fmt&amp;#34; ) type Student struct { name string age int } func main() { var i *int // *i = 10 // panic: runtime error: invalid memory address or nil pointer dereference 	fmt.Println(i) // fmt.Println(*i)  num := new(int) fmt.</description>
    </item>
    
    <item>
      <title>理解io多路复用</title>
      <link>https://zhangyh.me/posts/misc/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link>
      <pubDate>Sat, 03 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/misc/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</guid>
      <description>之前对io多路复用有诸多疑惑，看了很多文章还是不甚了解——它是什么，它要解决什么问题。最近刚好需要分析golang网络轮询器，趁此机会，把io多路复用的相关内容都总结记录一下。
为什么需要io多路复用模型? 当我们开启一个socket的时候，需要对发起的连接进行响应。
阻塞io 阻塞io流程如图 如果使用阻塞io，我们可能会有下面类似的代码框架。
listenfd = socket() // 创建socket bind(listenfd, addr) // 将socketfd和服务器地址绑定 listend(listenfd) // 转换为监听套接字  while(1) { connfd = accept(listenfd) // 阻塞建立连接  new thread func(){ int n = read(connfd, buf) // 阻塞读数据  do_something() // 业务代码  close(connfd) //关闭连接套接字  } } 在accept()建立起连接后，我们会使用多线程来接手连接套接字connfd，阻塞的读取客户端发送来的内容。
 每个连接都要开启一个线程来阻塞读取数据，但大多数线程都处于阻塞状态，造成了严重的线程浪费  非阻塞io 非阻塞io流程如图
如果使用非阻塞io，我们可能会有下面类似的代码框架
while(1) { connfd = accept(listenfd); // 阻塞建立连接  append(fds, connfd) for fd in fds { fcntl(connfd, F_SETFL, O_NONBLOCK); int n = read(connfd, buffer); if n !</description>
    </item>
    
    <item>
      <title>Go调度 | 3. goroutine的创建和执行</title>
      <link>https://zhangyh.me/posts/golang/go%E8%B0%83%E5%BA%A63-goroutine%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%89%A7%E8%A1%8C/</link>
      <pubDate>Thu, 01 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/golang/go%E8%B0%83%E5%BA%A63-goroutine%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%89%A7%E8%A1%8C/</guid>
      <description>【go调度】3. goroutine的创建和执行 参考上篇文章对文章对程序启动过程的分析，这里仍旧沿着上次分析的思路来分析main gorotine的创建和调度过程。
go程序的启动 TEXT runtime·rt0_go&amp;lt;ABIInternal&amp;gt;(SB),NOSPLIT,$0 .... // 初始化系统核心, 获取CPU的核数并放在global变量ncpu中  CALL	runtime·osinit(SB) // 初始化schedule  CALL	runtime·schedinit(SB) MOVQ	$runtime·mainPC(SB), AX	// entry  PUSHQ	AX PUSHQ	$0	// arg size  // 创建新的goroutine来执行程序(main()函数)  CALL	runtime·newproc(SB) POPQ	AX POPQ	AX // 主线程进入调度循环，运行刚刚创建的 goroutine  CALL	runtime·mstart(SB) // mstart是不会返回的，如果返回，终止程序  CALL	runtime·abort(SB)	// mstart should never return  RET main goroutine newproc() 该函数创建出main goroutine
func newproc(siz int32, fn *funcval) { argp := add(unsafe.</description>
    </item>
    
    <item>
      <title>Go调度 | 4. 调度策略</title>
      <link>https://zhangyh.me/posts/golang/go%E8%B0%83%E5%BA%A64-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</link>
      <pubDate>Thu, 01 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/golang/go%E8%B0%83%E5%BA%A64-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</guid>
      <description>【go调度】4. 调度策略 前文分析了scheduler的初始化以及goroutine创建和执行，略过了调度策略的内容。
有关调度策略的部分主要位于调度函数schedule()中，本文将具体分析。
schedule() func schedule() { _g_ := getg() top: var gp *g .... // 全局队列  if gp == nil { // 为了公平起见，每调度61次，就去全局队列优先获取goroutine  // 避免两个本地队列中的goroutine循环调度,导致全局队列中的goroutine得不到运行  if _g_.m.p.ptr().schedtick%61 == 0 &amp;amp;&amp;amp; sched.runqsize &amp;gt; 0 { lock(&amp;amp;sched.lock) gp = globrunqget(_g_.m.p.ptr(), 1) unlock(&amp;amp;sched.lock) } } // 本地队列  if gp == nil { // 从本地队列优先获取goroutine  gp, inheritTime = runqget(_g_.m.p.ptr()) } // 本地和全局都没有获取到goroutine，就需要从其他的p本地队列中偷取  // 如果偷取不到当前线程会block，知道返回可用的goroutine  if gp == nil { gp, inheritTime = findrunnable() // blocks until work is available  } .</description>
    </item>
    
    <item>
      <title>GMP源码分析</title>
      <link>https://zhangyh.me/posts/golang/gmp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1/</link>
      <pubDate>Wed, 30 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/golang/gmp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1/</guid>
      <description>准备写一个有关go schedule系列的文章，目前已经有很多这方面的内容，但为了记录学习过程和未来复习，我还是决定亲自输出写东西。 该系列预期包括以下内容：
 GMP模型 scheduler的初始化 main goroutine和非main goroutine的启动和结束 如何调度 &amp;ndash; 全局队列，局部队列，working-stealing 何时调度 &amp;ndash;被动，主动，抢占式  创建go routine start=&amp;gt;start: 开始op1=&amp;gt;operation: 获取go func()的func和argsop2=&amp;gt;operation: 切换至g0，使用g0创建对应的Gop3=&amp;gt;operation: gfget(p) 从当前的P获取空闲G;op4=&amp;gt;operation: 参数复制到G,清除堆,pc:func,sp:goexit1op5=&amp;gt;operation: runqput(p,newg,true); 将G加入P的runnable数组;end=&amp;gt;end: 结束start-&amp;gt;op1op1-&amp;gt;op2op2-&amp;gt;op3op3-&amp;gt;op4op4-&amp;gt;op5op5-&amp;gt;end创建P References  Go 语言调度器与 Goroutine 实现原理 | Go 语言设计与实现 golang 源码学习之GMP (goroutine) - 简书 go/runtime2.go at master · golang/go [译]Go 调度器: M, P 和 G | 鸟窝 Golang调度器源码分析 Golang的协程调度器原理及GMP设计思想？ · Golang修养之路 · 看云 Golang源码探索(二) 协程的实现原理 - q303248153 - 博客园  </description>
    </item>
    
    <item>
      <title>Go调度 | 1. GMP模型</title>
      <link>https://zhangyh.me/posts/golang/go%E8%B0%83%E5%BA%A61-gmp%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Wed, 30 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/golang/go%E8%B0%83%E5%BA%A61-gmp%E6%A8%A1%E5%9E%8B/</guid>
      <description>本节深入先从宏观上介绍GMP模型，然后再通过源码进行深入了解。
线程和协程 协程是用户态的线程，他的管理和调度都是在用户态进行的，协程与线程相比有以下的优势：
 内存占用 线程内存占用约为4MB，且大小固定。协程内存占用约为2KB，并且是弹性可拓展的。 线程的内存分配往往一方面会造成内存的浪费，另一方面也会有栈溢出的风险。 创建和切换 线程的创建和切换都需要在内核态进行，并且线程切换时有很多寄存器需要进行现场保护。 而协程的创建和切换都是用户态的，并且线程保护的内容相对较少  GMP模型  G: goroutine协程,即我们定义的 go func(){} P: processor处理器，是一种抽象的、用于G执行的局部资源 M: machine，也即thread，对应实际的内核线程
 GMP结构 这部分主要从源码层面分析GMP的结构
G结构 我们暂时忽略一些对我们分析没有影响的字段。
type g struct { stack stack // goroutine 使用的栈[stack.lo, stack.hi] 	stackguard0 uintptr stackguard1 uintptr // 用于栈空间的动态变化  m *m // 与当前g绑定的m  sched gobuf // goroutine的运行线程，主要为寄存器信息 	param unsafe.Pointer // warkup 唤醒时传递的参数 	atomicstatus uint32 // goroutine的状态 	goid int64 // goroutine id 	schedlink guintptr // 指向全局goroutine队列中的的下一个  // go阻塞的时间和原因 	waitsince int64 // approx time when the g become blocked 	waitreason waitReason // if status==Gwaiting  // 抢占调度相关 	preempt bool // preemption signal, duplicates stackguard0 = stackpreempt 	preemptStop bool // transition to _Gpreempted on preemption; otherwise, just deschedule 	preemptShrink bool // shrink stack at synchronous safe point } 其中atomicstatus存储了goroutine的状态，这里列举一些重要的状态</description>
    </item>
    
    <item>
      <title>Go调度 | 2. scheduler初始化</title>
      <link>https://zhangyh.me/posts/golang/go%E8%B0%83%E5%BA%A62-scheduler%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Wed, 30 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/golang/go%E8%B0%83%E5%BA%A62-scheduler%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>上篇文章结尾告诉我们了几个重要的全局变量，本篇文章会用到
allm *m // 所有的m构成的一个链表，包括下面的m0 allp []*p // 保存所有的p，len(allp) == gomaxprocs  ncpu int32 // 系统中cpu核的数量，程序启动时由runtime代码初始化 gomaxprocs int32 // p的最大值，默认等于ncpu，但可以通过GOMAXPROCS修改  m0 m // 代表进程的主线程 g0 g // m0的g0，也就是m0.g0 = &amp;amp;g0 go程序的启动 当我们运行一个main()函数来启动整个go程序的时候，他的启动流程是什么，这里我们从源码方面仔细分析下整个流程。
对于linux下的程序来说，入口文件在runtime/rt0_linux_amd64.s，
 具体我们是如何判断入口文件的，可以参考这篇文章，文章简单易懂
 TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8 JMP	_rt0_amd64(SB) 跳转到runtime/asm_amd64.s文件的_rt0_amd64(SB)函数
// 操作系统内核传递过来的参数argc和argv数组的地址分别放在DI和SI寄存器中 // 然后跳转到 rt0_go 去执行 TEXT _rt0_amd64(SB),NOSPLIT,$-8 MOVQ	0(SP), DI	// argc 	LEAQ	8(SP), SI	// argv 	JMP	runtime·rt0_go(SB) 跳转到runtime·rt0_go函数，我们保留该函数的主要流程
TEXT runtime·rt0_go&amp;lt;ABIInternal&amp;gt;(SB),NOSPLIT,$0 // 拷贝argc和argv到指定位置  MOVQ	DI, AX	// argc  MOVQ	SI, BX	// argv  SUBQ	$(4*8+7), SP	// 2args 2auto  ANDQ	$~15, SP MOVQ	AX, 16(SP) MOVQ	BX, 24(SP) // 为g0分配栈空间，g0的栈一般相对较大  // 之后会专门写一篇分析g0的文章  MOVQ	$runtime·g0(SB), DI LEAQ	(-64*1024+104)(SP), BX MOVQ	BX, g_stackguard0(DI) MOVQ	BX, g_stackguard1(DI) MOVQ	BX, (g_stack+stack_lo)(DI) MOVQ	SP, (g_stack+stack_hi)(DI) // .</description>
    </item>
    
    <item>
      <title>Go | SliceTricks</title>
      <link>https://zhangyh.me/posts/golang/slicetricks/</link>
      <pubDate>Tue, 29 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/golang/slicetricks/</guid>
      <description>【译】SliceTricks  原文链接: https://github.com/golang/go/wiki/SliceTricks
 go官方给出了许多slice操作的tricks，这里记录一下，并在最后给出examples
AppendVector a = append(a, b...) Copy // 正常拷贝 b := make([]int, len(a)) copy(b, a) // 正常拷贝的one-line实现，但实际上边速度要慢一点 b = append(make([]int, 0, len(a)), a...) // 如果拷贝后还需要添加更多的元素，可以使用这种方式 // 但通常来说上面的方式更快 append([]int(nil), a...) // or append(a[:0:0], a...) Cut a = append(a[:i], a[j:]...) Delete a = append(a[:i], a[i:]...) Delete without preserving order a[i] = a[len(a) - 1] a = a[:len(a) - 1] [admonition color=&amp;ldquo;red&amp;rdquo;]如果数组类型为指针，或者时带有指针的结构体,那么上述的操作很可能会导致内存泄露的发生:一些元素仍然被a引用，但没有被垃圾回收器回收。可以使用以下的方式避免内存泄漏[/admonition]
 Cut
 copy(a[i:], a[j:]) for k, n := len(a)-j+i, len(a); k &amp;lt; n; k++ { a[k] = nil // or the zero value of T } a = a[:len(a)-j+i]  Delete</description>
    </item>
    
    <item>
      <title>人民币汇率与人民币国际化—翟东升</title>
      <link>https://zhangyh.me/posts/thinking/%E4%BA%BA%E6%B0%91%E5%B8%81%E6%B1%87%E7%8E%87%E4%B8%8E%E4%BA%BA%E6%B0%91%E5%B8%81%E5%9B%BD%E9%99%85%E5%8C%96/</link>
      <pubDate>Sun, 27 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhangyh.me/posts/thinking/%E4%BA%BA%E6%B0%91%E5%B8%81%E6%B1%87%E7%8E%87%E4%B8%8E%E4%BA%BA%E6%B0%91%E5%B8%81%E5%9B%BD%E9%99%85%E5%8C%96/</guid>
      <description>《人民币汇率与人民币国际化》-翟东升 总结翟东升老师的《人民币汇率与人民币国际化》基础课所讲的内容和知识点
1. 对人民币汇率的错误预测 看空人民币的五个错误理由 看空人民的观点错在哪 人民币是强势货币 2. 汇率的影响因素  短期看市场情绪，中期看政府调控，长期看市场
 影响长期汇率的直接因素 长期来看影响汇率最直接最有效的因素就是一个国家可贸易品的价格水平。可贸易品的加权平均价决定了汇率。
 两国之间的可贸易品价格如果差距太大，就会进行倒买倒卖，最终实现抛补平衡
 技术水平 和 人口老龄化 决定了可贸易品的价格，从而影响了汇率 (参考日本)
影响汇率的六个深层因素   国家能力 政府财政开支占国家GDP的比例越高，汇率往往越坚挺。
政府需要提供各种有效的公共产品(医疗、市场、教育、基础设施、贸易协定、治安秩序、商业秩序)。各种企业的成功离不开政府提供的公共产品。
  贸易开放度 出口所占比例。
   凡是想做空日元的都没有什么好下场
  要素特征 出口贸易品类型。 出口以能源、原材料、大宗商品、矿石等为主，汇率呈顺周期。 出口制成品为主，汇率呈逆周期。(汇率下跌，出口工业制成品获得价格优势，贸易顺差扩大，汇率获得上涨动能)
  文明类型 汇率最坚挺的两大文明：新教文明和东亚文明 鼓励生产，不鼓励消费
   新教文明：西欧、北欧、北美洲、大洋洲 东亚文明：日本、朝鲜半岛、中国大陆、中国台湾、中国香港、新加坡、越南
 比较软的货币所属文明：小乘佛教 不鼓励生产，不鼓励消费
贬值很厉害的货币所属文明：罗马天主教、东正教和伊斯兰教 不鼓励生产，鼓励消费
人均智商 宗教严肃度  海外投资的汇率风险 中国企业和资本出海需要重点防范：目标国的汇率风险 (结合上面所讲的因素进行思考)</description>
    </item>
    
  </channel>
</rss>
