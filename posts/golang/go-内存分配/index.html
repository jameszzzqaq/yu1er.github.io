<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Go | 内存分配 | yuler's blog</title>
<meta name=keywords content>
<meta name=description content="Go | 内存分配 设计原理 Go的内存分配参考了TCMalloc的核心思想。
 每一个线程都可以获得一个用于无锁分配小对象的缓存，这样可以让并行程序分配小对象（<=32KB）非常高效。 TCMalloc 管理的堆由一组页组成，一组连续的页面被表示为 span。当分配的对象大于 32KB，将使用页堆（Page Heap）进行内存分配。  相关struct mspan mspan是Go语言内存管理的基本单元。
type mspan struct { next *mspan // 链表指针 	prev *mspan // 链表指针  startAddr uintptr // span 起始地址 	npages uintptr // page的数量  spanclass spanClass // size class and noscan (uint8) 	state mSpanStateBox // span状态 	limit uintptr // end of data in span } 这里只列出了关心的主要字段。
 mspan使用 next和prev指针构成双向链表 startAddr确定了mspan所在内存的地址，npages确定了内存地址范围 每个mspan都管理这npages数量的page（注意这里的page不是操作系统的page，它是操作系统page的整数倍） state为mspan的状态，不细说。  spanClass 这是mspan中一个很核心的字段，spanClass是跨度类，它决定了mspan中管理的存储对象的大小和个数。">
<meta name=author content="yuler">
<link rel=canonical href=https://zhangyh.me/posts/golang/go-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style>
<link rel=icon href=https://zhangyh.me/icon/jiaran16.ico>
<link rel=icon type=image/png sizes=16x16 href=https://zhangyh.me/icon/jiaran16.ico>
<link rel=icon type=image/png sizes=32x32 href=https://zhangyh.me/icon/jiaran32.ico>
<link rel=apple-touch-icon href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="Go | 内存分配">
<meta property="og:description" content="Go | 内存分配 设计原理 Go的内存分配参考了TCMalloc的核心思想。
 每一个线程都可以获得一个用于无锁分配小对象的缓存，这样可以让并行程序分配小对象（<=32KB）非常高效。 TCMalloc 管理的堆由一组页组成，一组连续的页面被表示为 span。当分配的对象大于 32KB，将使用页堆（Page Heap）进行内存分配。  相关struct mspan mspan是Go语言内存管理的基本单元。
type mspan struct { next *mspan // 链表指针 	prev *mspan // 链表指针  startAddr uintptr // span 起始地址 	npages uintptr // page的数量  spanclass spanClass // size class and noscan (uint8) 	state mSpanStateBox // span状态 	limit uintptr // end of data in span } 这里只列出了关心的主要字段。
 mspan使用 next和prev指针构成双向链表 startAddr确定了mspan所在内存的地址，npages确定了内存地址范围 每个mspan都管理这npages数量的page（注意这里的page不是操作系统的page，它是操作系统page的整数倍） state为mspan的状态，不细说。  spanClass 这是mspan中一个很核心的字段，spanClass是跨度类，它决定了mspan中管理的存储对象的大小和个数。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhangyh.me/posts/golang/go-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"><meta property="og:image" content="https://zhangyh.me/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-07-17T00:00:00+00:00">
<meta property="article:modified_time" content="2021-07-17T00:00:00+00:00"><meta property="og:site_name" content="yuler's blog">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhangyh.me/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="Go | 内存分配">
<meta name=twitter:description content="Go | 内存分配 设计原理 Go的内存分配参考了TCMalloc的核心思想。
 每一个线程都可以获得一个用于无锁分配小对象的缓存，这样可以让并行程序分配小对象（<=32KB）非常高效。 TCMalloc 管理的堆由一组页组成，一组连续的页面被表示为 span。当分配的对象大于 32KB，将使用页堆（Page Heap）进行内存分配。  相关struct mspan mspan是Go语言内存管理的基本单元。
type mspan struct { next *mspan // 链表指针 	prev *mspan // 链表指针  startAddr uintptr // span 起始地址 	npages uintptr // page的数量  spanclass spanClass // size class and noscan (uint8) 	state mSpanStateBox // span状态 	limit uintptr // end of data in span } 这里只列出了关心的主要字段。
 mspan使用 next和prev指针构成双向链表 startAddr确定了mspan所在内存的地址，npages确定了内存地址范围 每个mspan都管理这npages数量的page（注意这里的page不是操作系统的page，它是操作系统page的整数倍） state为mspan的状态，不细说。  spanClass 这是mspan中一个很核心的字段，spanClass是跨度类，它决定了mspan中管理的存储对象的大小和个数。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zhangyh.me/posts/"},{"@type":"ListItem","position":2,"name":"Go | 内存分配","item":"https://zhangyh.me/posts/golang/go-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go | 内存分配","name":"Go | 内存分配","description":"Go | 内存分配 设计原理 Go的内存分配参考了TCMalloc的核心思想。\n 每一个线程都可以获得一个用于无锁分配小对象的缓存，这样可以让并行程序分配小对象（\u0026lt;=32KB）非常高效。 TCMalloc 管理的堆由一组页组成，一组连续的页面被表示为 span。当分配的对象大于 32KB，将使用页堆（Page Heap）进行内存分配。  相关struct mspan mspan是Go语言内存管理的基本单元。\ntype mspan struct { next *mspan // 链表指针 \tprev *mspan // 链表指针  startAddr uintptr // span 起始地址 \tnpages uintptr // page的数量  spanclass spanClass // size class and noscan (uint8) \tstate mSpanStateBox // span状态 \tlimit uintptr // end of data in span } 这里只列出了关心的主要字段。\n mspan使用 next和prev指针构成双向链表 startAddr确定了mspan所在内存的地址，npages确定了内存地址范围 每个mspan都管理这npages数量的page（注意这里的page不是操作系统的page，它是操作系统page的整数倍） state为mspan的状态，不细说。  spanClass 这是mspan中一个很核心的字段，spanClass是跨度类，它决定了mspan中管理的存储对象的大小和个数。","keywords":[],"articleBody":"Go | 内存分配 设计原理 Go的内存分配参考了TCMalloc的核心思想。\n 每一个线程都可以获得一个用于无锁分配小对象的缓存，这样可以让并行程序分配小对象（ TCMalloc 管理的堆由一组页组成，一组连续的页面被表示为 span。当分配的对象大于 32KB，将使用页堆（Page Heap）进行内存分配。  相关struct mspan mspan是Go语言内存管理的基本单元。\ntype mspan struct { next *mspan // 链表指针 \tprev *mspan // 链表指针  startAddr uintptr // span 起始地址 \tnpages uintptr // page的数量  spanclass spanClass // size class and noscan (uint8) \tstate mSpanStateBox // span状态 \tlimit uintptr // end of data in span } 这里只列出了关心的主要字段。\n mspan使用 next和prev指针构成双向链表 startAddr确定了mspan所在内存的地址，npages确定了内存地址范围 每个mspan都管理这npages数量的page（注意这里的page不是操作系统的page，它是操作系统page的整数倍） state为mspan的状态，不细说。  spanClass 这是mspan中一个很核心的字段，spanClass是跨度类，它决定了mspan中管理的存储对象的大小和个数。\nGo语言中一共有68种跨度类，每个跨度类会存储特定大小的对象并且需要分配指定数量的page。\nclass_to_size表示每个跨度类的字节大小。 class_to_allocnpages表示每个跨度类需要分配page的数量。\nID为0的特殊跨度类，用于管理大对象。\n跨度类的最后一个二进制位是nospan标记，即表示对象是否包含指针，用于加快垃圾回收。\ntype spanClass uint8 // 前7位表示跨度类ID，最后一位标记是否包含指针  _NumSizeClasses = 68 var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 24, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768} var class_to_allocnpages = [_NumSizeClasses]uint8{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 3, 2, 3, 1, 3, 2, 3, 4, 5, 6, 1, 7, 6, 5, 4, 3, 5, 7, 2, 9, 7, 5, 8, 3, 10, 7, 4} 每个mspan的内存都用于指定跨度类的内存分配。在分配内存时，首先需要选择最适合的跨度类，从而避免内存浪费。\nmcache mcache是线程缓存，它和GMP模型中的P绑定，主要用于为用户小于32KB的微、小对象分配内存。\n每个mcache有 $68 * 2$(_NumSizeClasses ) 个 mspan。\n_NumSizeClasses = 68 numSpanClasses = _NumSizeClasses  1 type mcache struct { // 微为对象 \ttiny uintptr tinyoffset uintptr tinyAllocs uintptr // 小对象 \talloc [numSpanClasses]*mspan // spans to allocate from, indexed by spanClass } 上面我们说过跨度类共有68种，这里每个跨度类又分为有指针和无指针两类。\n对于小对象，在mcache中，为对象寻找mspan的流程如下：\n 计算对象所需内存大小size 根据size到size class映射，计算出所需的size class 根据size class和对象是否包含指针计算出span class 获取该span class指向的span。  但是如果对应的mspan没有剩余空间可被分配时，mcache就需要通过refill()函数向mcentral申请mspan,mcache拿到mspan后继续分配内存。\nmcentral type mcentral struct { spanclass spanClass partial [2]spanSet full [2]spanSet } 每个中心缓存都会管理某个跨度类的内存管理单元，它会同时持有两个 runtime.spanSet，分别存储包含空闲对象和不包含空闲对象的内存管理单元。\n当mcentral中的span不够用时，会找到mheap分配页数并获取新的mspan结构。\nmheap mheap是内存分配的核心结构体，每个Go语言程序有一个对应的全局变量。\ntype mheap struct { // lock must only be acquired on the system stack, otherwise a g \t// could self-deadlock if its stack grows with the lock held. \tlock mutex // arenas is the heap arena map. It points to the metadata for \t// the heap for every arena frame of the entire usable virtual \t// address space. \t// \t// Use arenaIndex to compute indexes into this array. \t// \t// For regions of the address space that are not backed by the \t// Go heap, the arena map contains nil. \t// \t// Modifications are protected by mheap_.lock. Reads can be \t// performed without locking; however, a given entry can \t// transition from nil to non-nil at any time when the lock \t// isn't held. (Entries never transitions back to nil.) \t// \t// In general, this is a two-level mapping consisting of an L1 \t// map and possibly many L2 maps. This saves space when there \t// are a huge number of arena frames. However, on many \t// platforms (even 64-bit), arenaL1Bits is 0, making this \t// effectively a single-level map. In this case, arenas[0] \t// will never be nil. \tarenas [1  arenaL1Bits]*[1  arenaL2Bits]*heapArena // central free lists for small size classes. \t// the padding makes sure that the mcentrals are \t// spaced CacheLinePadSize bytes apart, so that each mcentral.lock \t// gets its own cache line. \t// central is indexed by spanClass. \tcentral [numSpanClasses]struct { mcentral mcentral pad [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral{})%cpu.CacheLinePadSize]byte } } mheap包含两个重要部分，一个是mcentral数组，它管理所有的跨度类内存。另一个是管理堆内存区域的arenas。\nGo 语言所有的内存空间都由如下所示的二维矩阵 heapArena 管理，这个二维矩阵管理的内存可以是不连续的，每一个 heapArena 都会管理 64MB 的操作系统的内存空间。\n内存分配  大于 32K 的大对象直接从 mheap 分配。 小于 16B 的使用 mcache 的微型分配器分配 对象大小在 16B ~ 32K 之间的的，首先通过计算使用的大小规格，然后使用 mcache 中对应大小规格的块分配 如果对应的大小规格在 mcache 中没有可用的块，则向 mcentral 申请 如果 mcentral 中没有可用的块，则向 mheap 申请，并根据 BestFit 算法找到最合适的 mspan。如果申请到的 mspan 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 mspan 放回 mheap 的空闲列表。 如果 mheap 中没有可用 span，则向操作系统申请一系列新的页（最小 1MB）。 Go 会在操作系统分配超大的页（称作 arena）。分配一大批页会减少和操作系统通信的成本  References  https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator https://qiankunli.github.io/2020/11/22/go_mm.html https://zhuanlan.zhihu.com/p/352133292 https://www.linuxzen.com/go-memory-allocator-visual-guide.html https://segmentfault.com/a/1190000039815122 https://segmentfault.com/a/1190000023869256?utm_source=sf-similar-article  ","wordCount":"597","inLanguage":"en","datePublished":"2021-07-17T00:00:00Z","dateModified":"2021-07-17T00:00:00Z","author":{"@type":"Person","name":"yuler"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhangyh.me/posts/golang/go-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},"publisher":{"@type":"Organization","name":"yuler's blog","logo":{"@type":"ImageObject","url":"https://zhangyh.me/icon/jiaran16.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhangyh.me/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://zhangyh.me/archives/ title=archives>
<span>archives</span>
</a>
</li>
<li>
<a href=https://zhangyh.me/categories/ title=categories>
<span>categories</span>
</a>
</li>
<li>
<a href=https://zhangyh.me/tags/ title=tags>
<span>tags</span>
</a>
</li>
<li>
<a href=https://zhangyh.me/search/ title="search (Alt + /)" accesskey=/>
<span>search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://zhangyh.me/>Home</a>&nbsp;»&nbsp;<a href=https://zhangyh.me/posts/>Posts</a></div>
<h1 class=post-title>
Go | 内存分配
</h1>
<div class=post-meta>7-17&nbsp;·&nbsp;yuler&nbsp;|&nbsp;<a href=https://github.com/yu1er/blog-src/content/tree/main/posts/golang/Go%20%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d.md rel="noopener noreferrer" target=_blank>Edit</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#go--%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d aria-label="Go | 内存分配">Go | 内存分配</a></li>
<li>
<a href=#%e8%ae%be%e8%ae%a1%e5%8e%9f%e7%90%86 aria-label=设计原理>设计原理</a></li>
<li>
<a href=#%e7%9b%b8%e5%85%b3struct aria-label=相关struct>相关struct</a><ul>
<li>
<a href=#mspan aria-label=mspan>mspan</a><ul>
<li>
<a href=#spanclass aria-label=spanClass>spanClass</a></li></ul>
</li>
<li>
<a href=#mcache aria-label=mcache>mcache</a></li>
<li>
<a href=#mcentral aria-label=mcentral>mcentral</a></li>
<li>
<a href=#mheap aria-label=mheap>mheap</a></li></ul>
</li>
<li>
<a href=#%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d aria-label=内存分配>内存分配</a></li>
<li>
<a href=#references aria-label=References>References</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=go--内存分配>Go | 内存分配<a hidden class=anchor aria-hidden=true href=#go--内存分配>#</a></h1>
<h1 id=设计原理>设计原理<a hidden class=anchor aria-hidden=true href=#设计原理>#</a></h1>
<p>Go的内存分配参考了<code>TCMalloc</code>的核心思想。</p>
<ol>
<li>每一个线程都可以获得一个用于无锁分配小对象的缓存，这样可以让并行程序分配小对象（&lt;=32KB）非常高效。</li>
<li>TCMalloc 管理的堆由一组页组成，一组连续的页面被表示为 span。当分配的对象大于 32KB，将使用页堆（Page Heap）进行内存分配。</li>
</ol>
<h1 id=相关struct>相关struct<a hidden class=anchor aria-hidden=true href=#相关struct>#</a></h1>
<h2 id=mspan>mspan<a hidden class=anchor aria-hidden=true href=#mspan>#</a></h2>
<p><code>mspan</code>是Go语言内存管理的基本单元。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mspan</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>next</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>     <span style=color:#75715e>// 链表指针
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>prev</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>     <span style=color:#75715e>// 链表指针
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>startAddr</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// span 起始地址
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>npages</span>    <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// page的数量
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>spanclass</span>   <span style=color:#a6e22e>spanClass</span>     <span style=color:#75715e>// size class and noscan (uint8)
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>state</span>       <span style=color:#a6e22e>mSpanStateBox</span> <span style=color:#75715e>// span状态
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>limit</span>       <span style=color:#66d9ef>uintptr</span>       <span style=color:#75715e>// end of data in span
</span><span style=color:#75715e></span>}
</code></pre></div><p>这里只列出了关心的主要字段。</p>
<ol>
<li><code>mspan</code>使用 <code>next</code>和<code>prev</code>指针构成双向链表</li>
<li><code>startAddr</code>确定了<code>mspan</code>所在内存的地址，<code>npages</code>确定了内存地址范围</li>
<li>每个<code>mspan</code>都管理这<code>npages</code>数量的page（注意这里的page不是操作系统的page，它是操作系统page的整数倍）</li>
<li><code>state</code>为<code>mspan</code>的状态，不细说。</li>
</ol>
<h3 id=spanclass>spanClass<a hidden class=anchor aria-hidden=true href=#spanclass>#</a></h3>
<p>这是<code>mspan</code>中一个很核心的字段，<code>spanClass</code>是跨度类，它决定了<code>mspan</code>中管理的存储对象的大小和个数。</p>
<p>Go语言中一共有68种跨度类，每个跨度类会存储特定大小的对象并且需要分配指定数量的page。</p>
<p><code>class_to_size</code>表示每个跨度类的字节大小。
<code>class_to_allocnpages</code>表示每个跨度类需要分配page的数量。</p>
<p>ID为0的特殊跨度类，用于管理大对象。</p>
<p>跨度类的最后一个二进制位是<code>nospan</code>标记，即表示对象是否包含指针，用于加快垃圾回收。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>spanClass</span> <span style=color:#66d9ef>uint8</span> <span style=color:#75715e>// 前7位表示跨度类ID，最后一位标记是否包含指针
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>_NumSizeClasses</span> = <span style=color:#ae81ff>68</span>

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>class_to_size</span> = [<span style=color:#a6e22e>_NumSizeClasses</span>]<span style=color:#66d9ef>uint16</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>24</span>, <span style=color:#ae81ff>32</span>, <span style=color:#ae81ff>48</span>, <span style=color:#ae81ff>64</span>, <span style=color:#ae81ff>80</span>, <span style=color:#ae81ff>96</span>, <span style=color:#ae81ff>112</span>, <span style=color:#ae81ff>128</span>, <span style=color:#ae81ff>144</span>, <span style=color:#ae81ff>160</span>, <span style=color:#ae81ff>176</span>, <span style=color:#ae81ff>192</span>, <span style=color:#ae81ff>208</span>, <span style=color:#ae81ff>224</span>, <span style=color:#ae81ff>240</span>, <span style=color:#ae81ff>256</span>, <span style=color:#ae81ff>288</span>, <span style=color:#ae81ff>320</span>, <span style=color:#ae81ff>352</span>, <span style=color:#ae81ff>384</span>, <span style=color:#ae81ff>416</span>, <span style=color:#ae81ff>448</span>, <span style=color:#ae81ff>480</span>, <span style=color:#ae81ff>512</span>, <span style=color:#ae81ff>576</span>, <span style=color:#ae81ff>640</span>, <span style=color:#ae81ff>704</span>, <span style=color:#ae81ff>768</span>, <span style=color:#ae81ff>896</span>, <span style=color:#ae81ff>1024</span>, <span style=color:#ae81ff>1152</span>, <span style=color:#ae81ff>1280</span>, <span style=color:#ae81ff>1408</span>, <span style=color:#ae81ff>1536</span>, <span style=color:#ae81ff>1792</span>, <span style=color:#ae81ff>2048</span>, <span style=color:#ae81ff>2304</span>, <span style=color:#ae81ff>2688</span>, <span style=color:#ae81ff>3072</span>, <span style=color:#ae81ff>3200</span>, <span style=color:#ae81ff>3456</span>, <span style=color:#ae81ff>4096</span>, <span style=color:#ae81ff>4864</span>, <span style=color:#ae81ff>5376</span>, <span style=color:#ae81ff>6144</span>, <span style=color:#ae81ff>6528</span>, <span style=color:#ae81ff>6784</span>, <span style=color:#ae81ff>6912</span>, <span style=color:#ae81ff>8192</span>, <span style=color:#ae81ff>9472</span>, <span style=color:#ae81ff>9728</span>, <span style=color:#ae81ff>10240</span>, <span style=color:#ae81ff>10880</span>, <span style=color:#ae81ff>12288</span>, <span style=color:#ae81ff>13568</span>, <span style=color:#ae81ff>14336</span>, <span style=color:#ae81ff>16384</span>, <span style=color:#ae81ff>18432</span>, <span style=color:#ae81ff>19072</span>, <span style=color:#ae81ff>20480</span>, <span style=color:#ae81ff>21760</span>, <span style=color:#ae81ff>24576</span>, <span style=color:#ae81ff>27264</span>, <span style=color:#ae81ff>28672</span>, <span style=color:#ae81ff>32768</span>}

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>class_to_allocnpages</span> = [<span style=color:#a6e22e>_NumSizeClasses</span>]<span style=color:#66d9ef>uint8</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>4</span>}
</code></pre></div><p>每个<code>mspan</code>的内存都用于指定跨度类的内存分配。在分配内存时，首先需要选择最适合的跨度类，从而避免内存浪费。</p>
<h2 id=mcache>mcache<a hidden class=anchor aria-hidden=true href=#mcache>#</a></h2>
<p><code>mcache</code>是线程缓存，它和GMP模型中的P绑定，主要用于为用户小于32KB的微、小对象分配内存。</p>
<p>每个<code>mcache</code>有 $68 * 2$(<code>_NumSizeClasses &lt;&lt; 1</code>) 个 <code>mspan</code>。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go>
<span style=color:#a6e22e>_NumSizeClasses</span> = <span style=color:#ae81ff>68</span>
<span style=color:#a6e22e>numSpanClasses</span> = <span style=color:#a6e22e>_NumSizeClasses</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mcache</span> <span style=color:#66d9ef>struct</span> {
  <span style=color:#75715e>// 微为对象
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>tiny</span>       <span style=color:#66d9ef>uintptr</span>
	<span style=color:#a6e22e>tinyoffset</span> <span style=color:#66d9ef>uintptr</span>
	<span style=color:#a6e22e>tinyAllocs</span> <span style=color:#66d9ef>uintptr</span>

  <span style=color:#75715e>// 小对象
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>alloc</span> [<span style=color:#a6e22e>numSpanClasses</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span> <span style=color:#75715e>// spans to allocate from, indexed by spanClass
</span><span style=color:#75715e></span>}
</code></pre></div><p>上面我们说过跨度类共有68种，这里每个跨度类又分为<strong>有指针</strong>和<strong>无指针</strong>两类。</p>
<p>对于<strong>小对象</strong>，在<code>mcache</code>中，为对象寻找<code>mspan</code>的流程如下：</p>
<ol>
<li>计算对象所需内存大小<code>size</code></li>
<li>根据<code>size</code>到<code>size class</code>映射，计算出所需的<code>size class</code></li>
<li>根据<code>size class</code>和对象是否包含指针计算出<code>span class</code></li>
<li>获取该<code>span class</code>指向的<code>span</code>。</li>
</ol>
<p>但是如果对应的<code>mspan</code>没有剩余空间可被分配时，<code>mcache</code>就需要通过<code>refill()</code>函数向<code>mcentral</code>申请<code>mspan</code>,<code>mcache</code>拿到<code>mspan</code>后继续分配内存。</p>
<h2 id=mcentral>mcentral<a hidden class=anchor aria-hidden=true href=#mcentral>#</a></h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mcentral</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>spanclass</span> <span style=color:#a6e22e>spanClass</span>
	<span style=color:#a6e22e>partial</span>  [<span style=color:#ae81ff>2</span>]<span style=color:#a6e22e>spanSet</span>
	<span style=color:#a6e22e>full</span>     [<span style=color:#ae81ff>2</span>]<span style=color:#a6e22e>spanSet</span>
}
</code></pre></div><p>每个中心缓存都会管理某个跨度类的内存管理单元，它会同时持有两个 runtime.spanSet，分别存储包含空闲对象和不包含空闲对象的内存管理单元。</p>
<p>当<code>mcentral</code>中的<code>span</code>不够用时，会找到<code>mheap</code>分配页数并获取新的<code>mspan</code>结构。</p>
<h2 id=mheap>mheap<a hidden class=anchor aria-hidden=true href=#mheap>#</a></h2>
<p><code>mheap</code>是内存分配的核心结构体，每个Go语言程序有一个对应的全局变量。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mheap</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#75715e>// lock must only be acquired on the system stack, otherwise a g
</span><span style=color:#75715e></span>	<span style=color:#75715e>// could self-deadlock if its stack grows with the lock held.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>lock</span>      <span style=color:#a6e22e>mutex</span>

	<span style=color:#75715e>// arenas is the heap arena map. It points to the metadata for
</span><span style=color:#75715e></span>	<span style=color:#75715e>// the heap for every arena frame of the entire usable virtual
</span><span style=color:#75715e></span>	<span style=color:#75715e>// address space.
</span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span><span style=color:#75715e></span>	<span style=color:#75715e>// Use arenaIndex to compute indexes into this array.
</span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span><span style=color:#75715e></span>	<span style=color:#75715e>// For regions of the address space that are not backed by the
</span><span style=color:#75715e></span>	<span style=color:#75715e>// Go heap, the arena map contains nil.
</span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span><span style=color:#75715e></span>	<span style=color:#75715e>// Modifications are protected by mheap_.lock. Reads can be
</span><span style=color:#75715e></span>	<span style=color:#75715e>// performed without locking; however, a given entry can
</span><span style=color:#75715e></span>	<span style=color:#75715e>// transition from nil to non-nil at any time when the lock
</span><span style=color:#75715e></span>	<span style=color:#75715e>// isn&#39;t held. (Entries never transitions back to nil.)
</span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span><span style=color:#75715e></span>	<span style=color:#75715e>// In general, this is a two-level mapping consisting of an L1
</span><span style=color:#75715e></span>	<span style=color:#75715e>// map and possibly many L2 maps. This saves space when there
</span><span style=color:#75715e></span>	<span style=color:#75715e>// are a huge number of arena frames. However, on many
</span><span style=color:#75715e></span>	<span style=color:#75715e>// platforms (even 64-bit), arenaL1Bits is 0, making this
</span><span style=color:#75715e></span>	<span style=color:#75715e>// effectively a single-level map. In this case, arenas[0]
</span><span style=color:#75715e></span>	<span style=color:#75715e>// will never be nil.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>arenas</span> [<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>arenaL1Bits</span>]<span style=color:#f92672>*</span>[<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>arenaL2Bits</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>heapArena</span>

	<span style=color:#75715e>// central free lists for small size classes.
</span><span style=color:#75715e></span>	<span style=color:#75715e>// the padding makes sure that the mcentrals are
</span><span style=color:#75715e></span>	<span style=color:#75715e>// spaced CacheLinePadSize bytes apart, so that each mcentral.lock
</span><span style=color:#75715e></span>	<span style=color:#75715e>// gets its own cache line.
</span><span style=color:#75715e></span>	<span style=color:#75715e>// central is indexed by spanClass.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>central</span> [<span style=color:#a6e22e>numSpanClasses</span>]<span style=color:#66d9ef>struct</span> {
		<span style=color:#a6e22e>mcentral</span> <span style=color:#a6e22e>mcentral</span>
		<span style=color:#a6e22e>pad</span>      [<span style=color:#a6e22e>cpu</span>.<span style=color:#a6e22e>CacheLinePadSize</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>mcentral</span>{})<span style=color:#f92672>%</span><span style=color:#a6e22e>cpu</span>.<span style=color:#a6e22e>CacheLinePadSize</span>]<span style=color:#66d9ef>byte</span>
	}
}
</code></pre></div><p>mheap包含两个重要部分，一个是<code>mcentral</code>数组，它管理所有的跨度类内存。另一个是管理堆内存区域的<code>arenas</code>。</p>
<p>Go 语言所有的内存空间都由如下所示的二维矩阵 <code>heapArena</code> 管理，这个二维矩阵管理的内存可以是不连续的，每一个 <code>heapArena</code> 都会管理 <code>64MB</code> 的操作系统的内存空间。</p>
<h1 id=内存分配>内存分配<a hidden class=anchor aria-hidden=true href=#内存分配>#</a></h1>
<ol>
<li>大于 32K 的大对象直接从 <code>mheap</code> 分配。</li>
<li>小于 16B 的使用 <code>mcache</code> 的微型分配器分配</li>
<li>对象大小在 16B ~ 32K 之间的的，首先通过计算使用的大小规格，然后使用 <code>mcache</code> 中对应大小规格的块分配</li>
<li>如果对应的大小规格在 <code>mcache</code> 中没有可用的块，则向 <code>mcentral</code> 申请</li>
<li>如果 <code>mcentral</code> 中没有可用的块，则向 <code>mheap</code> 申请，并根据 <code>BestFit</code> 算法找到最合适的 <code>mspan</code>。如果申请到的 <code>mspan</code> 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 <code>mspan</code> 放回 <code>mheap</code> 的空闲列表。</li>
<li>如果 <code>mheap</code> 中没有可用 <code>span</code>，则向操作系统申请一系列新的页（最小 1MB）。 Go 会在操作系统分配超大的页（称作 <code>arena</code>）。分配一大批页会减少和操作系统通信的成本</li>
</ol>
<h1 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h1>
<ol>
<li><a href=https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator>https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator</a></li>
<li><a href=https://qiankunli.github.io/2020/11/22/go_mm.html>https://qiankunli.github.io/2020/11/22/go_mm.html</a></li>
<li><a href=https://zhuanlan.zhihu.com/p/352133292>https://zhuanlan.zhihu.com/p/352133292</a></li>
<li><a href=https://www.linuxzen.com/go-memory-allocator-visual-guide.html>https://www.linuxzen.com/go-memory-allocator-visual-guide.html</a></li>
<li><a href=https://segmentfault.com/a/1190000039815122>https://segmentfault.com/a/1190000039815122</a></li>
<li><a href="https://segmentfault.com/a/1190000023869256?utm_source=sf-similar-article">https://segmentfault.com/a/1190000023869256?utm_source=sf-similar-article</a></li>
</ol>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=https://zhangyh.me/posts/paper/aug/zen/>
<span class=title>« Prev Page</span>
<br>
<span>Zen: a high-throughput log-free OLTP engine for non-volatile main memory</span>
</a>
<a class=next href=https://zhangyh.me/posts/golang/go-context/>
<span class=title>Next Page »</span>
<br>
<span>Go | context</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://zhangyh.me/>yuler's blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>