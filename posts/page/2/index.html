<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Posts | yuler's blog</title>
<meta name=keywords content>
<meta name=description content="Posts - yuler's blog">
<meta name=author content="Me">
<link rel=canonical href=https://zhangyh.me/posts/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.9f1d947375927e9847272b1f4e9be81336f539e513bf04d52cade31f81cad1af.css integrity="sha256-nx2Uc3WSfphHJysfTpvoEzb1OeUTvwTVLK3jH4HK0a8=" rel="preload stylesheet" as=style>
<link rel=preload href=/apple-touch-icon.png as=image>
<link rel=icon href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<link rel=alternate type=application/rss+xml href=https://zhangyh.me/posts/index.xml>
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="Posts">
<meta property="og:description" content="ExampleSite description">
<meta property="og:type" content="website">
<meta property="og:url" content="https://zhangyh.me/posts/"><meta property="og:image" content="https://zhangyh.me/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhangyh.me/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="Posts">
<meta name=twitter:description content="ExampleSite description">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zhangyh.me/posts/"}]}</script>
</head>
<body class=list id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhangyh.me/ accesskey=h title="Home (Alt + H)">
<img src=/apple-touch-icon.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://zhangyh.me/categories/ title=categories>
<span>categories</span>
</a>
</li>
<li>
<a href=https://zhangyh.me/tags/ title=tags>
<span>tags</span>
</a>
</li>
<li>
<a href=https://example.org title=example.org>
<span>example.org</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<header class=page-header><div class=breadcrumbs><a href=https://zhangyh.me/>Home</a></div>
<h1>Posts</h1>
</header>
<article class=post-entry>
<header class=entry-header>
<h2>Go | 内存分配
</h2>
</header>
<section class=entry-content>
<p>设计原理 Go的内存分配参考了TCMalloc的核心思想。
每一个线程都可以获得一个用于无锁分配小对象的缓存，这样可以让并行程序分配小对象（&lt;=32KB）非常高效。 TCMalloc 管理的堆由一组页组成，一组连续的页面被表示为 span。当分配的对象大于 32KB，将使用页堆（Page Heap）进行内存分配。 相关struct mspan mspan是Go语言内存管理的基本单元。
这里只列出了关心的主要字段。
mspan使用 next和prev指针构成双向链表 startAddr确定了mspan所在内存的地址，npages确定了内存地址范围 每个mspan都管理这npages数量的page（注意这里的page不是操作系统的page，它是操作系统page的整数倍） state为mspan的状态，不细说。 spanClass 这是mspan中一个很核心的字段，spanClass是跨度类，它决定了mspan中管理的存储对象的大小和个数。
Go语言中一共有68种跨度类，每个跨度类会存储特定大小的对象并且需要分配指定数量的page。
class_to_size表示每个跨度类的字节大小。
class_to_allocnpages表示每个跨度类需要分配page的数量。
ID为0的特殊跨度类，用于管理大对象。
跨度类的最后一个二进制位是nospan标记，即表示对象是否包含指针，用于加快垃圾回收。
每个mspan的内存都用于指定跨度类的内存分配。在分配内存时，首先需要选择最适合的跨度类，从而避免内存浪费。
mcache mcache是线程缓存，它和GMP模型中的P绑定，主要用于为用户小于32KB的微、小对象分配内存。
每个mcache有 $68 * 2$(_NumSizeClasses &lt;&lt; 1) 个 mspan。
上面我们说过跨度类共有68种，这里每个跨度类又分为有指针和无指针两类。
对于小对象，在mcache中，为对象寻找mspan的流程如下：
计算对象所需内存大小size 根据size到size class映射，计算出所需的size class 根据size class和对象是否包含指针计算出span class 获取该span class指向的span。 但是如果对应的mspan没有剩余空间可被分配时，mcache就需要通过refill()函数向mcentral申请mspan,mcache拿到mspan后继续分配内存。
mcentral 每个中心缓存都会管理某个跨度类的内存管理单元，它会同时持有两个 runtime.spanSet，分别存储包含空闲对象和不包含空闲对象的内存管理单元。
当mcentral中的span不够用时，会找到mheap分配页数并获取新的mspan结构。
mheap mheap是内存分配的核心结构体，每个Go语言程序有一个对应的全局变量。
mheap包含两个重要部分，一个是mcentral数组，它管理所有的跨度类内存。另一个是管理堆内存区域的arenas。
Go 语言所有的内存空间都由如下所示的二维矩阵 heapArena 管理，这个二维矩阵管理的内存可以是不连续的，每一个 heapArena 都会管理 64MB 的操作系统的内存空间。
内存分配 大于 32K 的大对象直接从 mheap 分配。 小于 16B 的使用 mcache 的微型分配器分配 对象大小在 16B ~ 32K 之间的的，首先通过计算使用的大小规格，然后使用 mcache 中对应大小规格的块分配 如果对应的大小规格在 mcache 中没有可用的块，则向 mcentral 申请 如果 mcentral 中没有可用的块，则向 mheap 申请，并根据 BestFit 算法找到最合适的 mspan。如果申请到的 mspan 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 mspan 放回 mheap 的空闲列表。 如果 mheap 中没有可用 span，则向操作系统申请一系列新的页（最小 1MB）。 Go 会在操作系统分配超大的页（称作 arena）。分配一大批页会减少和操作系统通信的成本 References https://draveness....</p>
</section>
<footer class=entry-footer>July 17, 2021&nbsp;·&nbsp;1 min&nbsp;·&nbsp;yuler</footer>
<a class=entry-link aria-label="post link to Go | 内存分配" href=https://zhangyh.me/topics/golang/go-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Go | context
</h2>
</header>
<section class=entry-content>
<p>什么是context context 主要用来在goroutine之间传递上下文信息，包括：取消信号、超时时间、截止时间、k-v 等。
可以通过以下个函数创建实现对应的功能:
context.WithCancel(): 创建带有取消函数的context，上层goroutine调用cancelFunc函数，向下层传递取消信号 context.WithTimeout(): 创建带有超时的context，同时创建计时器，超时的时候调用context的cancelFunc；当然也可以主动调用cacelFunc context.WithDeadline(): 和带超时的context类似，实际底层WithTimeout就调用了WithDeadline； return WithDeadline(parent, time.Now().Add(timeout)) context.WithValue(): 创建带值的context 使用场景 1. 链路传值 注意值的流向只能从上到下，上层context是获取不到下层传入的值的 传入的context不能为nil，可以传context.Background()或context.TODO() 2. 链路并发控制 context最主要的作用是解决cancelation问题，也就是通过上层goroutine来释放下层goroutine。
可以把主要的并发模型归为两类，wait和cancel
Wait主要通过sync.WaitGroup实现，Cancel则需要通过context.Context来实现
这里只是用了带有cancel信号的context，当然也可以使用带有超时和截止时间的context
使用原则 不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。 不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context.TODO() 不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据。例如：登陆的 session、cookie 等。 同一个 context 可能会被传递到多个 goroutine，别担心，context 是并发安全的。 References https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context https://www.cnblogs.com/qcrao-2018/p/11007503.html https://36kr.com/p/1721518997505 https://faiface.github.io/post/context-should-go-away-go2/ https://golang.org/pkg/context/#example_WithDeadline https://xie.infoq.cn/article/3e18dd6d335d1a6ab552a88e8 </p>
</section>
<footer class=entry-footer>July 16, 2021&nbsp;·&nbsp;1 min&nbsp;·&nbsp;yuler</footer>
<a class=entry-link aria-label="post link to Go | context" href=https://zhangyh.me/topics/golang/go-context.html></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Go | make和new
</h2>
</header>
<section class=entry-content>
<p>区别 方法 作用对象 返回值 new 值类型和用户定义类型 指向对象的指针 make 内置引用类型slice, map, channel 引用类型本身 new new用于为值类型或用户自定义的类型分配内存，并初始化零值，返回零值指针。
make make是为了初始化slice，map，channel这三种引用类型的。
针对这三种类型，分别调用runtime.makeslice，runtime.makemap，runtime.makechan函数。
make 相对于 new 来说，做的事情更多，new 只是开辟了内存空间， make 为更加复杂的数据结构开辟内存空间并对一些字段进行初始化
总结 new用于为值类型或用户自定义的类型 make只能用于slice,map,channel new一般不常用，通常直接使用结构体字面量</p>
</section>
<footer class=entry-footer>July 11, 2021&nbsp;·&nbsp;1 min&nbsp;·&nbsp;yuler</footer>
<a class=entry-link aria-label="post link to Go | make和new" href=https://zhangyh.me/topics/golang/go-make%E5%92%8Cnew.html></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>1418. 点菜展示表
</h2>
</header>
<section class=entry-content>
<p>题目地址
Solution 重点是模拟整个流程。
golang中没有set，但可以使用map[int]struct{}来表示set，其中的value为struct{}，不会占用内存
Code 模拟 References 1. Sets in Go</p>
</section>
<footer class=entry-footer>July 6, 2021&nbsp;·&nbsp;1 min&nbsp;·&nbsp;yuler</footer>
<a class=entry-link aria-label="post link to 1418. 点菜展示表" href=https://zhangyh.me/topics/leetcode/1418-%E7%82%B9%E8%8F%9C%E5%B1%95%E7%A4%BA%E8%A1%A8.html></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>理解io多路复用
</h2>
</header>
<section class=entry-content>
<p>之前对io多路复用有诸多疑惑，看了很多文章还是不甚了解——它是什么，它要解决什么问题。最近刚好需要分析golang网络轮询器，趁此机会，把io多路复用的相关内容都总结记录一下。
为什么需要io多路复用模型? 当我们开启一个socket的时候，需要对发起的连接进行响应。
阻塞io 阻塞io流程如图
如果使用阻塞io，我们可能会有下面类似的代码框架。
在accept()建立起连接后，我们会使用多线程来接手连接套接字connfd，阻塞的读取客户端发送来的内容。
每个连接都要开启一个线程来阻塞读取数据，但大多数线程都处于阻塞状态，造成了严重的线程浪费 非阻塞io 非阻塞io流程如图
如果使用非阻塞io，我们可能会有下面类似的代码框架
将建立的连接放到数组中，然后进行轮询，当有能够读取到消息的时候，再开启新的线程进一步处理。
轮询时使用系统调用read，导致用户态和内核态的频繁切换 io多路复用 考虑到上述两种io模型的缺点，提出了io多路复用，使用一个线程监听多个fd，同时又能减少系统调用的次数。
io多路复用包括三种模型select, poll和epoll。
select selet流程如图
select的思路是，将监听的fd数组从用户空间拷贝到内核空间，由内核负责遍历fd数组，确定哪些fd是可读写的，然后再将可读写的fd进行标记，拷贝标记数组到用户空间，并返回总的可读写的数量。再由用户进行遍历标记数组，处理相应的fd。
select由以下的问题：
fd数组的大小有限制，最大为1024 fd数组从用户空间到内核空间的频繁拷贝 用户还是需要根据返回的可读fd大小，对标记数组进行遍历，判断具体可操作的fd是哪个 poll poll使用链表代替了数组，解决了最大监听数1024的限制，但频繁拷贝和遍历问题仍未得到解决
epoll 针对select的三个问题，epoll进行了改进
可监控的fd数量没有限制 数据结构位于内核中，无需用户每次从用户空间拷贝，只需要告诉内核需要修改的部分即可。 内核只会将有io事件的fd返回给用户，避免了多余的遍历操作。 用户把需要监听的io事件添加到内核空间的红黑树中，对于每一个事件都会通过回调函数与网卡驱动建立回调关系，当相应的事件发生时，就会调用回调函数，通过回调函数把发生的事件添加到事件队列，当通过epoll_wait()检查是否有事件发生时，只需要检查队列是否为空即可，如果不为空，就把队列中的内容复制到用户态，同时将事件数量返回给用户。
epoll还是用了共享内存加速了用户空间和内核空间的消息传递。
epoll有LT(level trigger)和ET(edge trigger)两种模式：
水平触发(LT)：只要fd的事件还未处理（比如数据还没有读），每次epoll_wait都会返回该事件，提醒用户处理 边缘触发(ET): 当epoll_wait检测到事件并通知用户时，用户必须立马处理，否则下次也不会通知该事件。 该术语使用了脉冲信号相关的属于，很形象的表达了它们的功能。水平触发就是水平信号，只要事件不处理，就会一直发送该信号。边缘触发就是上升沿和下降沿，事件只会通知一次。
总结 &lt;th style="text-align: center;"> select &lt;/th> &lt;th style="text-align: center;"> poll &lt;/th> &lt;th style="text-align: center;"> epoll &lt;/th> &lt;td style="text-align: center;"> 遍历 &lt;/td> &lt;td style="text-align: center;"> 遍历 &lt;/td> &lt;td style="text-align: center;"> 回调 &lt;/td> &lt;td style="text-align: center;"> 数组 &lt;/td> &lt;td style="text-align: center;"> 链表 &lt;/td> &lt;td style="text-align: center;"> 红黑树 &lt;/td> &lt;td style="text-align: center;"> O(n) &lt;/td> &lt;td style="text-align: center;"> O(n) &lt;/td> &lt;td style="text-align: center;"> O(1) &lt;/td> &lt;td style="text-align: center;"> 1024 &lt;/td> &lt;td style="text-align: center;"> 无上限 &lt;/td> &lt;td style="text-align: center;"> 无上限 &lt;/td> &lt;td style="text-align: center;"> 每次拷贝所有数据 &lt;/td> &lt;td style="text-align: center;"> 每次拷贝所有数据 &lt;/td> &lt;td style="text-align: center;"> 拷贝相应的增删改操作 &lt;/td> References 1....</p>
</section>
<footer class=entry-footer>July 3, 2021&nbsp;·&nbsp;1 min&nbsp;·&nbsp;yuler</footer>
<a class=entry-link aria-label="post link to 理解io多路复用" href=https://zhangyh.me/topics/misc/%E7%90%86%E8%A7%A3io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html></a>
</article>
<footer class=page-footer>
<nav class=pagination>
<a class=prev href=https://zhangyh.me/posts/>« Prev Page</a>
<a class=next href=https://zhangyh.me/posts/page/3/>Next Page »</a>
</nav>
</footer>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://zhangyh.me/>yuler's blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>