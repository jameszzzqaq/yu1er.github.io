<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>yuler's blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod,Yuler">
<meta name=description content="yuler's blog">
<meta name=author content="yuler">
<link rel=canonical href=https://zhangyh.me/>
<meta name=google-site-verification content="G-JP3WQ36T5K">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabcsadf">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style>
<link rel=icon href=https://zhangyh.me/icon/jiaran16.ico>
<link rel=icon type=image/png sizes=16x16 href=https://zhangyh.me/icon/jiaran16.ico>
<link rel=icon type=image/png sizes=32x32 href=https://zhangyh.me/icon/jiaran32.ico>
<link rel=apple-touch-icon href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<link rel=alternate type=application/rss+xml href=https://zhangyh.me/index.xml>
<link rel=alternate type=application/json href=https://zhangyh.me/index.json>
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JP3WQ36T5K"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JP3WQ36T5K',{anonymize_ip:!1})}</script>
<meta property="og:title" content="yuler's blog">
<meta property="og:description" content="yuler's blog">
<meta property="og:type" content="website">
<meta property="og:url" content="https://zhangyh.me/"><meta property="og:image" content="https://zhangyh.me/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="yuler's blog">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhangyh.me/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="yuler's blog">
<meta name=twitter:description content="yuler's blog">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"yuler's blog","url":"https://zhangyh.me/","description":"yuler\u0026#39;s blog","thumbnailUrl":"https://zhangyh.me/icon/jiaran16.ico","sameAs":["mailto:zyh.me@outlook.com","https://github.com/yu1er"]}</script>
</head>
<body class=list id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhangyh.me/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://zhangyh.me/archives/ title=archives>
<span>archives</span>
</a>
</li>
<li>
<a href=https://zhangyh.me/categories/ title=categories>
<span>categories</span>
</a>
</li>
<li>
<a href=https://zhangyh.me/tags/ title=tags>
<span>tags</span>
</a>
</li>
<li>
<a href=https://zhangyh.me/search/ title="search (Alt + /)" accesskey=/>
<span>search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-entry>
<header class=entry-header>
<h2>Redesigning LSMs for nonvolatile memory with NoveLSM
</h2>
</header>
<section class=entry-content>
<p>Introduction 和目前的存储技术（例如flash、硬盘）相比， NVM有着以下的没有被LSM考虑的优点：
对于持久存储的随机访问的高性能 in-place update的低成本 (具体是?) 低时延、高带宽为application-level的并行化提供了机会 作者认为探索redesign适用于NVM的LSM是有意义的，而不是design a new data structure。 基于以下考量：
未来几年NVM和SSD共存，形成异质存储，而不是完全取代。redesign LSM可以在利用NVM的优点的前提下，同时不失去ssd和硬盘最优化的优势。 redesign lsm能为现有的应用提供向后兼容 保证批量写入NVM同样重要（NVM写延迟为DRAM的5-10倍） Motivation 单纯的硬件NVM的读写是SSD的100倍左右，但在LevelDB在NVM和SSD上的差异只有4-7倍 因此可以说目前的LSM没有充分利用NVM的硬件优势，软件开销较大
Insert Latency insert latency来源有三个方面：
WAL memtable insert compaction 对于compaction 内存中的mutable memtable在写满之后会刷新成immutable memtable，由后台进程将其压缩进磁盘，同时新开一个mutable memtable，来接管写入 问题是新的mutable memtable写满之后，如果immutable memtable还没有刷到磁盘内，就会造成系统的停顿 当进行大量的写入时，这会成为insert latency的主要来源。
可能会说，让memtable大一点不就可以解决，但这会带来一系列的问题：
增大memtable会带来双倍的内存占用，因为mutable memtable和immutable memtable需要同时增大 WAL的磁盘占用也会更大，因为他需要容纳更多的指令 LSM为了性能并不commit log。 Third, LSMs suchas LevelDB and RocksDB do not enforce commits (sync) when writing to a log; as a result, an application crash or power-failure could lead to data loss...</p>
</section>
<footer class=entry-footer>8-3&nbsp;·&nbsp;yuler</footer>
<a class=entry-link aria-label="post link to Redesigning LSMs for nonvolatile memory with NoveLSM" href=https://zhangyh.me/topics/paper/novelsm.html></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Zen: a high-throughput log-free OLTP engine for non-volatile main memory
</h2>
</header>
<section class=entry-content>
<p>Design Overview Hybrid Table(HTable) tuple heap in NVM Met-Cache in DRAM per-thread NVM-tuple managers. Metadata in NVM Transaction and Indices in DRAM NVM heap 所有的tuple持久化到NVM中的tuple heap，它由大小为2MB的pages组成 其中可能同时存在某个数据的多个版本 (tupleId, Tx-CTS)唯一确定一个tuple
LP: 在commited transaction中最后一个被持久化的tuple，将该标记记为1 Tx-CTS: 每个事务在线程内都有唯一ID，单调递增。 Deleted: 被删除 Met-Cache NVM heap在DRAM中的缓存
Clock bit: 用于Clock置换策略 Active bit: 事务正在使用该tuple Dirty bit: 被修改，当事务中途被absort，根据dirty位重新到NVM Heap获取tuple Copy bit: tuple被复制 CC-Meta：用于DRAM中的并发控制时，存储对应的信息。Zen中的并发控制完全实现在DRAM中，支持多种并发控制策略。 Indices in DRAM 在DRAM维护索引。crash后会重建。索引指向Met-Cache或者NVM heap中的tuple
Transaction-Private Data 线程私有 用于事务并发访问 存储相应数据...</p>
</section>
<footer class=entry-footer>8-3&nbsp;·&nbsp;yuler</footer>
<a class=entry-link aria-label="post link to Zen: a high-throughput log-free OLTP engine for non-volatile main memory" href=https://zhangyh.me/posts/paper/aug/zen/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Go | 内存分配
</h2>
</header>
<section class=entry-content>
<p>Go | 内存分配 设计原理 Go的内存分配参考了TCMalloc的核心思想。
每一个线程都可以获得一个用于无锁分配小对象的缓存，这样可以让并行程序分配小对象（&lt;=32KB）非常高效。 TCMalloc 管理的堆由一组页组成，一组连续的页面被表示为 span。当分配的对象大于 32KB，将使用页堆（Page Heap）进行内存分配。 相关struct mspan mspan是Go语言内存管理的基本单元。
type mspan struct { next *mspan // 链表指针 prev *mspan // 链表指针 startAddr uintptr // span 起始地址 npages uintptr // page的数量 spanclass spanClass // size class and noscan (uint8) state mSpanStateBox // span状态 limit uintptr // end of data in span } 这里只列出了关心的主要字段。
mspan使用 next和prev指针构成双向链表 startAddr确定了mspan所在内存的地址，npages确定了内存地址范围 每个mspan都管理这npages数量的page（注意这里的page不是操作系统的page，它是操作系统page的整数倍） state为mspan的状态，不细说。 spanClass 这是mspan中一个很核心的字段，spanClass是跨度类，它决定了mspan中管理的存储对象的大小和个数。...</p>
</section>
<footer class=entry-footer>7-17&nbsp;·&nbsp;yuler</footer>
<a class=entry-link aria-label="post link to Go | 内存分配" href=https://zhangyh.me/posts/golang/go-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Go | context
</h2>
</header>
<section class=entry-content>
<p>Go | context 什么是context context 主要用来在goroutine之间传递上下文信息，包括：取消信号、超时时间、截止时间、k-v 等。
可以通过以下个函数创建实现对应的功能:
context.WithCancel(): 创建带有取消函数的context，上层goroutine调用cancelFunc函数，向下层传递取消信号 context.WithTimeout(): 创建带有超时的context，同时创建计时器，超时的时候调用context的cancelFunc；当然也可以主动调用cacelFunc context.WithDeadline(): 和带超时的context类似，实际底层WithTimeout就调用了WithDeadline； return WithDeadline(parent, time.Now().Add(timeout)) context.WithValue(): 创建带值的context 使用场景 1. 链路传值 func Test1() { ctx := context.WithValue(context.Background(), "key", "value") go handleChainA1(ctx) go handleChainA2(ctx) time.Sleep(2 * time.Second) } func handleChainA1(ctx context.Context) { log.Println("handleChainA1", ctx.Value("key")) go handleChainB(context.WithValue(ctx, "key2", "value2")) } func handleChainA2(ctx context.Context) { log.Println("handleChainA2", ctx.Value("key")) } func handleChainB(ctx context.Context) { log.Println("handleChainB", ctx.Value("key")) log.Println("handleChainB", ctx.Value("key2")) } func main() { Test1() } 注意值的流向只能从上到下，上层context是获取不到下层传入的值的 传入的context不能为nil，可以传context....</p>
</section>
<footer class=entry-footer>7-16&nbsp;·&nbsp;yuler</footer>
<a class=entry-link aria-label="post link to Go | context" href=https://zhangyh.me/posts/golang/go-context/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Go | make和new
</h2>
</header>
<section class=entry-content>
<p>区别 方法 作用对象 返回值 new 值类型和用户定义类型 指向对象的指针 make 内置引用类型slice, map, channel 引用类型本身 值类型: 引用类型：
new new用于为值类型或用户自定义的类型分配内存，并初始化零值，返回零值指针。
package main import ( "fmt" ) type Student struct { name string age int } func main() { var i *int // *i = 10 // panic: runtime error: invalid memory address or nil pointer dereference fmt.Println(i) // fmt.Println(*i) num := new(int) fmt....</p>
</section>
<footer class=entry-footer>7-11&nbsp;·&nbsp;yuler</footer>
<a class=entry-link aria-label="post link to Go | make和new" href=https://zhangyh.me/posts/golang/go-make%E5%92%8Cnew/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>理解io多路复用
</h2>
</header>
<section class=entry-content>
<p>之前对io多路复用有诸多疑惑，看了很多文章还是不甚了解——它是什么，它要解决什么问题。最近刚好需要分析golang网络轮询器，趁此机会，把io多路复用的相关内容都总结记录一下。
为什么需要io多路复用模型? 当我们开启一个socket的时候，需要对发起的连接进行响应。
阻塞io 阻塞io流程如图 如果使用阻塞io，我们可能会有下面类似的代码框架。
listenfd = socket() // 创建socket bind(listenfd, addr) // 将socketfd和服务器地址绑定 listend(listenfd) // 转换为监听套接字 while(1) { connfd = accept(listenfd) // 阻塞建立连接 new thread func(){ int n = read(connfd, buf) // 阻塞读数据 do_something() // 业务代码 close(connfd) //关闭连接套接字 } } 在accept()建立起连接后，我们会使用多线程来接手连接套接字connfd，阻塞的读取客户端发送来的内容。
每个连接都要开启一个线程来阻塞读取数据，但大多数线程都处于阻塞状态，造成了严重的线程浪费 非阻塞io 非阻塞io流程如图
如果使用非阻塞io，我们可能会有下面类似的代码框架
while(1) { connfd = accept(listenfd); // 阻塞建立连接 append(fds, connfd) for fd in fds { fcntl(connfd, F_SETFL, O_NONBLOCK); int n = read(connfd, buffer); if n !...</p>
</section>
<footer class=entry-footer>7-3&nbsp;·&nbsp;yuler</footer>
<a class=entry-link aria-label="post link to 理解io多路复用" href=https://zhangyh.me/posts/misc/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Go调度 | 3. goroutine的创建和执行
</h2>
</header>
<section class=entry-content>
<p>【go调度】3. goroutine的创建和执行 参考上篇文章对文章对程序启动过程的分析，这里仍旧沿着上次分析的思路来分析main gorotine的创建和调度过程。
go程序的启动 TEXT runtime·rt0_go&lt;ABIInternal>(SB),NOSPLIT,$0 .... // 初始化系统核心, 获取CPU的核数并放在global变量ncpu中 CALL runtime·osinit(SB) // 初始化schedule CALL runtime·schedinit(SB) MOVQ $runtime·mainPC(SB), AX // entry PUSHQ AX PUSHQ $0 // arg size // 创建新的goroutine来执行程序(main()函数) CALL runtime·newproc(SB) POPQ AX POPQ AX // 主线程进入调度循环，运行刚刚创建的 goroutine CALL runtime·mstart(SB) // mstart是不会返回的，如果返回，终止程序 CALL runtime·abort(SB) // mstart should never return RET main goroutine newproc() 该函数创建出main goroutine
func newproc(siz int32, fn *funcval) { argp := add(unsafe....</p>
</section>
<footer class=entry-footer>7-1&nbsp;·&nbsp;yuler</footer>
<a class=entry-link aria-label="post link to Go调度 | 3. goroutine的创建和执行" href=https://zhangyh.me/posts/golang/go%E8%B0%83%E5%BA%A63-goroutine%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%89%A7%E8%A1%8C/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Go调度 | 4. 调度策略
</h2>
</header>
<section class=entry-content>
<p>【go调度】4. 调度策略 前文分析了scheduler的初始化以及goroutine创建和执行，略过了调度策略的内容。
有关调度策略的部分主要位于调度函数schedule()中，本文将具体分析。
schedule() func schedule() { _g_ := getg() top: var gp *g .... // 全局队列 if gp == nil { // 为了公平起见，每调度61次，就去全局队列优先获取goroutine // 避免两个本地队列中的goroutine循环调度,导致全局队列中的goroutine得不到运行 if _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 { lock(&sched.lock) gp = globrunqget(_g_.m.p.ptr(), 1) unlock(&sched.lock) } } // 本地队列 if gp == nil { // 从本地队列优先获取goroutine gp, inheritTime = runqget(_g_.m.p.ptr()) } // 本地和全局都没有获取到goroutine，就需要从其他的p本地队列中偷取 // 如果偷取不到当前线程会block，知道返回可用的goroutine if gp == nil { gp, inheritTime = findrunnable() // blocks until work is available } ....</p>
</section>
<footer class=entry-footer>7-1&nbsp;·&nbsp;yuler</footer>
<a class=entry-link aria-label="post link to Go调度 | 4. 调度策略" href=https://zhangyh.me/posts/golang/go%E8%B0%83%E5%BA%A64-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/></a>
</article>
<footer class=page-footer>
<nav class=pagination>
<a class=prev href=https://zhangyh.me/page/2/>« Prev Page</a>
<a class=next href=https://zhangyh.me/page/4/>Next Page »</a>
</nav>
</footer>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://zhangyh.me/>yuler's blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>