<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Go | 内存分配 | yuler's blog</title>
<meta name=keywords content>
<meta name=description content="设计原理 Go的内存分配参考了TCMalloc的核心思想。
 每一个线程都可以获得一个用于无锁分配小对象的缓存，这样可以让并行程序分配小对象（<=32KB）非常高效。 TCMalloc 管理的堆由一组页组成，一组连续的页面被表示为 span。当分配的对象大于 32KB，将使用页堆（Page Heap）进行内存分配。  相关struct mspan mspan是Go语言内存管理的基本单元。
这里只列出了关心的主要字段。
 mspan使用 next和prev指针构成双向链表 startAddr确定了mspan所在内存的地址，npages确定了内存地址范围 每个mspan都管理这npages数量的page（注意这里的page不是操作系统的page，它是操作系统page的整数倍） state为mspan的状态，不细说。  spanClass 这是mspan中一个很核心的字段，spanClass是跨度类，它决定了mspan中管理的存储对象的大小和个数。
Go语言中一共有68种跨度类，每个跨度类会存储特定大小的对象并且需要分配指定数量的page。
class_to_size表示每个跨度类的字节大小。
class_to_allocnpages表示每个跨度类需要分配page的数量。
ID为0的特殊跨度类，用于管理大对象。
跨度类的最后一个二进制位是nospan标记，即表示对象是否包含指针，用于加快垃圾回收。
每个mspan的内存都用于指定跨度类的内存分配。在分配内存时，首先需要选择最适合的跨度类，从而避免内存浪费。
mcache mcache是线程缓存，它和GMP模型中的P绑定，主要用于为用户小于32KB的微、小对象分配内存。
每个mcache有 $68 * 2$(_NumSizeClasses << 1) 个 mspan。
上面我们说过跨度类共有68种，这里每个跨度类又分为有指针和无指针两类。
对于小对象，在mcache中，为对象寻找mspan的流程如下：
 计算对象所需内存大小size 根据size到size class映射，计算出所需的size class 根据size class和对象是否包含指针计算出span class 获取该span class指向的span。  但是如果对应的mspan没有剩余空间可被分配时，mcache就需要通过refill()函数向mcentral申请mspan,mcache拿到mspan后继续分配内存。
mcentral 每个中心缓存都会管理某个跨度类的内存管理单元，它会同时持有两个 runtime.spanSet，分别存储包含空闲对象和不包含空闲对象的内存管理单元。
当mcentral中的span不够用时，会找到mheap分配页数并获取新的mspan结构。
mheap mheap是内存分配的核心结构体，每个Go语言程序有一个对应的全局变量。
mheap包含两个重要部分，一个是mcentral数组，它管理所有的跨度类内存。另一个是管理堆内存区域的arenas。
Go 语言所有的内存空间都由如下所示的二维矩阵 heapArena 管理，这个二维矩阵管理的内存可以是不连续的，每一个 heapArena 都会管理 64MB 的操作系统的内存空间。
内存分配  大于 32K 的大对象直接从 mheap 分配。 小于 16B 的使用 mcache 的微型分配器分配 对象大小在 16B ~ 32K 之间的的，首先通过计算使用的大小规格，然后使用 mcache 中对应大小规格的块分配 如果对应的大小规格在 mcache 中没有可用的块，则向 mcentral 申请 如果 mcentral 中没有可用的块，则向 mheap 申请，并根据 BestFit 算法找到最合适的 mspan。如果申请到的 mspan 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 mspan 放回 mheap 的空闲列表。 如果 mheap 中没有可用 span，则向操作系统申请一系列新的页（最小 1MB）。 Go 会在操作系统分配超大的页（称作 arena）。分配一大批页会减少和操作系统通信的成本  References  https://draveness.">
<meta name=author content="yuler">
<link rel=canonical href=https://zhangyh.me/topics/golang/go-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.9f1d947375927e9847272b1f4e9be81336f539e513bf04d52cade31f81cad1af.css integrity="sha256-nx2Uc3WSfphHJysfTpvoEzb1OeUTvwTVLK3jH4HK0a8=" rel="preload stylesheet" as=style>
<link rel=preload href=/apple-touch-icon.png as=image>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="Go | 内存分配">
<meta property="og:description" content="设计原理 Go的内存分配参考了TCMalloc的核心思想。
 每一个线程都可以获得一个用于无锁分配小对象的缓存，这样可以让并行程序分配小对象（<=32KB）非常高效。 TCMalloc 管理的堆由一组页组成，一组连续的页面被表示为 span。当分配的对象大于 32KB，将使用页堆（Page Heap）进行内存分配。  相关struct mspan mspan是Go语言内存管理的基本单元。
这里只列出了关心的主要字段。
 mspan使用 next和prev指针构成双向链表 startAddr确定了mspan所在内存的地址，npages确定了内存地址范围 每个mspan都管理这npages数量的page（注意这里的page不是操作系统的page，它是操作系统page的整数倍） state为mspan的状态，不细说。  spanClass 这是mspan中一个很核心的字段，spanClass是跨度类，它决定了mspan中管理的存储对象的大小和个数。
Go语言中一共有68种跨度类，每个跨度类会存储特定大小的对象并且需要分配指定数量的page。
class_to_size表示每个跨度类的字节大小。
class_to_allocnpages表示每个跨度类需要分配page的数量。
ID为0的特殊跨度类，用于管理大对象。
跨度类的最后一个二进制位是nospan标记，即表示对象是否包含指针，用于加快垃圾回收。
每个mspan的内存都用于指定跨度类的内存分配。在分配内存时，首先需要选择最适合的跨度类，从而避免内存浪费。
mcache mcache是线程缓存，它和GMP模型中的P绑定，主要用于为用户小于32KB的微、小对象分配内存。
每个mcache有 $68 * 2$(_NumSizeClasses << 1) 个 mspan。
上面我们说过跨度类共有68种，这里每个跨度类又分为有指针和无指针两类。
对于小对象，在mcache中，为对象寻找mspan的流程如下：
 计算对象所需内存大小size 根据size到size class映射，计算出所需的size class 根据size class和对象是否包含指针计算出span class 获取该span class指向的span。  但是如果对应的mspan没有剩余空间可被分配时，mcache就需要通过refill()函数向mcentral申请mspan,mcache拿到mspan后继续分配内存。
mcentral 每个中心缓存都会管理某个跨度类的内存管理单元，它会同时持有两个 runtime.spanSet，分别存储包含空闲对象和不包含空闲对象的内存管理单元。
当mcentral中的span不够用时，会找到mheap分配页数并获取新的mspan结构。
mheap mheap是内存分配的核心结构体，每个Go语言程序有一个对应的全局变量。
mheap包含两个重要部分，一个是mcentral数组，它管理所有的跨度类内存。另一个是管理堆内存区域的arenas。
Go 语言所有的内存空间都由如下所示的二维矩阵 heapArena 管理，这个二维矩阵管理的内存可以是不连续的，每一个 heapArena 都会管理 64MB 的操作系统的内存空间。
内存分配  大于 32K 的大对象直接从 mheap 分配。 小于 16B 的使用 mcache 的微型分配器分配 对象大小在 16B ~ 32K 之间的的，首先通过计算使用的大小规格，然后使用 mcache 中对应大小规格的块分配 如果对应的大小规格在 mcache 中没有可用的块，则向 mcentral 申请 如果 mcentral 中没有可用的块，则向 mheap 申请，并根据 BestFit 算法找到最合适的 mspan。如果申请到的 mspan 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 mspan 放回 mheap 的空闲列表。 如果 mheap 中没有可用 span，则向操作系统申请一系列新的页（最小 1MB）。 Go 会在操作系统分配超大的页（称作 arena）。分配一大批页会减少和操作系统通信的成本  References  https://draveness.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhangyh.me/topics/golang/go-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html"><meta property="og:image" content="https://zhangyh.me/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-07-17T12:14:57+00:00">
<meta property="article:modified_time" content="2021-07-17T12:14:57+00:00"><meta property="og:site_name" content="ExampleSite">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhangyh.me/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="Go | 内存分配">
<meta name=twitter:description content="设计原理 Go的内存分配参考了TCMalloc的核心思想。
 每一个线程都可以获得一个用于无锁分配小对象的缓存，这样可以让并行程序分配小对象（<=32KB）非常高效。 TCMalloc 管理的堆由一组页组成，一组连续的页面被表示为 span。当分配的对象大于 32KB，将使用页堆（Page Heap）进行内存分配。  相关struct mspan mspan是Go语言内存管理的基本单元。
这里只列出了关心的主要字段。
 mspan使用 next和prev指针构成双向链表 startAddr确定了mspan所在内存的地址，npages确定了内存地址范围 每个mspan都管理这npages数量的page（注意这里的page不是操作系统的page，它是操作系统page的整数倍） state为mspan的状态，不细说。  spanClass 这是mspan中一个很核心的字段，spanClass是跨度类，它决定了mspan中管理的存储对象的大小和个数。
Go语言中一共有68种跨度类，每个跨度类会存储特定大小的对象并且需要分配指定数量的page。
class_to_size表示每个跨度类的字节大小。
class_to_allocnpages表示每个跨度类需要分配page的数量。
ID为0的特殊跨度类，用于管理大对象。
跨度类的最后一个二进制位是nospan标记，即表示对象是否包含指针，用于加快垃圾回收。
每个mspan的内存都用于指定跨度类的内存分配。在分配内存时，首先需要选择最适合的跨度类，从而避免内存浪费。
mcache mcache是线程缓存，它和GMP模型中的P绑定，主要用于为用户小于32KB的微、小对象分配内存。
每个mcache有 $68 * 2$(_NumSizeClasses << 1) 个 mspan。
上面我们说过跨度类共有68种，这里每个跨度类又分为有指针和无指针两类。
对于小对象，在mcache中，为对象寻找mspan的流程如下：
 计算对象所需内存大小size 根据size到size class映射，计算出所需的size class 根据size class和对象是否包含指针计算出span class 获取该span class指向的span。  但是如果对应的mspan没有剩余空间可被分配时，mcache就需要通过refill()函数向mcentral申请mspan,mcache拿到mspan后继续分配内存。
mcentral 每个中心缓存都会管理某个跨度类的内存管理单元，它会同时持有两个 runtime.spanSet，分别存储包含空闲对象和不包含空闲对象的内存管理单元。
当mcentral中的span不够用时，会找到mheap分配页数并获取新的mspan结构。
mheap mheap是内存分配的核心结构体，每个Go语言程序有一个对应的全局变量。
mheap包含两个重要部分，一个是mcentral数组，它管理所有的跨度类内存。另一个是管理堆内存区域的arenas。
Go 语言所有的内存空间都由如下所示的二维矩阵 heapArena 管理，这个二维矩阵管理的内存可以是不连续的，每一个 heapArena 都会管理 64MB 的操作系统的内存空间。
内存分配  大于 32K 的大对象直接从 mheap 分配。 小于 16B 的使用 mcache 的微型分配器分配 对象大小在 16B ~ 32K 之间的的，首先通过计算使用的大小规格，然后使用 mcache 中对应大小规格的块分配 如果对应的大小规格在 mcache 中没有可用的块，则向 mcentral 申请 如果 mcentral 中没有可用的块，则向 mheap 申请，并根据 BestFit 算法找到最合适的 mspan。如果申请到的 mspan 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 mspan 放回 mheap 的空闲列表。 如果 mheap 中没有可用 span，则向操作系统申请一系列新的页（最小 1MB）。 Go 会在操作系统分配超大的页（称作 arena）。分配一大批页会减少和操作系统通信的成本  References  https://draveness.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zhangyh.me/posts/"},{"@type":"ListItem","position":2,"name":"Go | 内存分配","item":"https://zhangyh.me/topics/golang/go-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go | 内存分配","name":"Go | 内存分配","description":"设计原理 Go的内存分配参考了TCMalloc的核心思想。\n 每一个线程都可以获得一个用于无锁分配小对象的缓存，这样可以让并行程序分配小对象（\u0026lt;=32KB）非常高效。 TCMalloc 管理的堆由一组页组成，一组连续的页面被表示为 span。当分配的对象大于 32KB，将使用页堆（Page Heap）进行内存分配。  相关struct mspan mspan是Go语言内存管理的基本单元。\n这里只列出了关心的主要字段。\n mspan使用 next和prev指针构成双向链表 startAddr确定了mspan所在内存的地址，npages确定了内存地址范围 每个mspan都管理这npages数量的page（注意这里的page不是操作系统的page，它是操作系统page的整数倍） state为mspan的状态，不细说。  spanClass 这是mspan中一个很核心的字段，spanClass是跨度类，它决定了mspan中管理的存储对象的大小和个数。\nGo语言中一共有68种跨度类，每个跨度类会存储特定大小的对象并且需要分配指定数量的page。\nclass_to_size表示每个跨度类的字节大小。\nclass_to_allocnpages表示每个跨度类需要分配page的数量。\nID为0的特殊跨度类，用于管理大对象。\n跨度类的最后一个二进制位是nospan标记，即表示对象是否包含指针，用于加快垃圾回收。\n每个mspan的内存都用于指定跨度类的内存分配。在分配内存时，首先需要选择最适合的跨度类，从而避免内存浪费。\nmcache mcache是线程缓存，它和GMP模型中的P绑定，主要用于为用户小于32KB的微、小对象分配内存。\n每个mcache有 $68 * 2$(_NumSizeClasses \u0026lt;\u0026lt; 1) 个 mspan。\n上面我们说过跨度类共有68种，这里每个跨度类又分为有指针和无指针两类。\n对于小对象，在mcache中，为对象寻找mspan的流程如下：\n 计算对象所需内存大小size 根据size到size class映射，计算出所需的size class 根据size class和对象是否包含指针计算出span class 获取该span class指向的span。  但是如果对应的mspan没有剩余空间可被分配时，mcache就需要通过refill()函数向mcentral申请mspan,mcache拿到mspan后继续分配内存。\nmcentral 每个中心缓存都会管理某个跨度类的内存管理单元，它会同时持有两个 runtime.spanSet，分别存储包含空闲对象和不包含空闲对象的内存管理单元。\n当mcentral中的span不够用时，会找到mheap分配页数并获取新的mspan结构。\nmheap mheap是内存分配的核心结构体，每个Go语言程序有一个对应的全局变量。\nmheap包含两个重要部分，一个是mcentral数组，它管理所有的跨度类内存。另一个是管理堆内存区域的arenas。\nGo 语言所有的内存空间都由如下所示的二维矩阵 heapArena 管理，这个二维矩阵管理的内存可以是不连续的，每一个 heapArena 都会管理 64MB 的操作系统的内存空间。\n内存分配  大于 32K 的大对象直接从 mheap 分配。 小于 16B 的使用 mcache 的微型分配器分配 对象大小在 16B ~ 32K 之间的的，首先通过计算使用的大小规格，然后使用 mcache 中对应大小规格的块分配 如果对应的大小规格在 mcache 中没有可用的块，则向 mcentral 申请 如果 mcentral 中没有可用的块，则向 mheap 申请，并根据 BestFit 算法找到最合适的 mspan。如果申请到的 mspan 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 mspan 放回 mheap 的空闲列表。 如果 mheap 中没有可用 span，则向操作系统申请一系列新的页（最小 1MB）。 Go 会在操作系统分配超大的页（称作 arena）。分配一大批页会减少和操作系统通信的成本  References  https://draveness.","keywords":[],"articleBody":"设计原理 Go的内存分配参考了TCMalloc的核心思想。\n 每一个线程都可以获得一个用于无锁分配小对象的缓存，这样可以让并行程序分配小对象（ TCMalloc 管理的堆由一组页组成，一组连续的页面被表示为 span。当分配的对象大于 32KB，将使用页堆（Page Heap）进行内存分配。  相关struct mspan mspan是Go语言内存管理的基本单元。\n这里只列出了关心的主要字段。\n mspan使用 next和prev指针构成双向链表 startAddr确定了mspan所在内存的地址，npages确定了内存地址范围 每个mspan都管理这npages数量的page（注意这里的page不是操作系统的page，它是操作系统page的整数倍） state为mspan的状态，不细说。  spanClass 这是mspan中一个很核心的字段，spanClass是跨度类，它决定了mspan中管理的存储对象的大小和个数。\nGo语言中一共有68种跨度类，每个跨度类会存储特定大小的对象并且需要分配指定数量的page。\nclass_to_size表示每个跨度类的字节大小。\nclass_to_allocnpages表示每个跨度类需要分配page的数量。\nID为0的特殊跨度类，用于管理大对象。\n跨度类的最后一个二进制位是nospan标记，即表示对象是否包含指针，用于加快垃圾回收。\n每个mspan的内存都用于指定跨度类的内存分配。在分配内存时，首先需要选择最适合的跨度类，从而避免内存浪费。\nmcache mcache是线程缓存，它和GMP模型中的P绑定，主要用于为用户小于32KB的微、小对象分配内存。\n每个mcache有 $68 * 2$(_NumSizeClasses ) 个 mspan。\n上面我们说过跨度类共有68种，这里每个跨度类又分为有指针和无指针两类。\n对于小对象，在mcache中，为对象寻找mspan的流程如下：\n 计算对象所需内存大小size 根据size到size class映射，计算出所需的size class 根据size class和对象是否包含指针计算出span class 获取该span class指向的span。  但是如果对应的mspan没有剩余空间可被分配时，mcache就需要通过refill()函数向mcentral申请mspan,mcache拿到mspan后继续分配内存。\nmcentral 每个中心缓存都会管理某个跨度类的内存管理单元，它会同时持有两个 runtime.spanSet，分别存储包含空闲对象和不包含空闲对象的内存管理单元。\n当mcentral中的span不够用时，会找到mheap分配页数并获取新的mspan结构。\nmheap mheap是内存分配的核心结构体，每个Go语言程序有一个对应的全局变量。\nmheap包含两个重要部分，一个是mcentral数组，它管理所有的跨度类内存。另一个是管理堆内存区域的arenas。\nGo 语言所有的内存空间都由如下所示的二维矩阵 heapArena 管理，这个二维矩阵管理的内存可以是不连续的，每一个 heapArena 都会管理 64MB 的操作系统的内存空间。\n内存分配  大于 32K 的大对象直接从 mheap 分配。 小于 16B 的使用 mcache 的微型分配器分配 对象大小在 16B ~ 32K 之间的的，首先通过计算使用的大小规格，然后使用 mcache 中对应大小规格的块分配 如果对应的大小规格在 mcache 中没有可用的块，则向 mcentral 申请 如果 mcentral 中没有可用的块，则向 mheap 申请，并根据 BestFit 算法找到最合适的 mspan。如果申请到的 mspan 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 mspan 放回 mheap 的空闲列表。 如果 mheap 中没有可用 span，则向操作系统申请一系列新的页（最小 1MB）。 Go 会在操作系统分配超大的页（称作 arena）。分配一大批页会减少和操作系统通信的成本  References  https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator https://qiankunli.github.io/2020/11/22/go_mm.html https://zhuanlan.zhihu.com/p/352133292 https://www.linuxzen.com/go-memory-allocator-visual-guide.html https://segmentfault.com/a/1190000039815122 https://segmentfault.com/a/1190000023869256?utm_source=sf-similar-article  ","wordCount":"114","inLanguage":"en","datePublished":"2021-07-17T12:14:57Z","dateModified":"2021-07-17T12:14:57Z","author":{"@type":"Person","name":"yuler"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhangyh.me/topics/golang/go-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html"},"publisher":{"@type":"Organization","name":"yuler's blog","logo":{"@type":"ImageObject","url":"https://zhangyh.me/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhangyh.me/ accesskey=h title="Home (Alt + H)">
<img src=/apple-touch-icon.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://zhangyh.me/categories/ title=categories>
<span>categories</span>
</a>
</li>
<li>
<a href=https://zhangyh.me/tags/ title=tags>
<span>tags</span>
</a>
</li>
<li>
<a href=https://zhangyh.me/archives/ title=archives>
<span>archives</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://zhangyh.me/>Home</a>&nbsp;»&nbsp;<a href=https://zhangyh.me/posts/>Posts</a></div>
<h1 class=post-title>
Go | 内存分配
</h1>
<div class=post-meta>July 17, 2021&nbsp;·&nbsp;1 min&nbsp;·&nbsp;yuler&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/go/2021-07-17-go-%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header>
<div class=post-content><h1 id=设计原理>设计原理<a hidden class=anchor aria-hidden=true href=#设计原理>#</a></h1>
<p>Go的内存分配参考了<code>TCMalloc</code>的核心思想。</p>
<ol>
<li>每一个线程都可以获得一个用于无锁分配小对象的缓存，这样可以让并行程序分配小对象（&lt;=32KB）非常高效。</li>
<li>TCMalloc 管理的堆由一组页组成，一组连续的页面被表示为 span。当分配的对象大于 32KB，将使用页堆（Page Heap）进行内存分配。</li>
</ol>
<h1 id=相关struct>相关struct<a hidden class=anchor aria-hidden=true href=#相关struct>#</a></h1>
<h2 id=mspan>mspan<a hidden class=anchor aria-hidden=true href=#mspan>#</a></h2>
<p><code>mspan</code>是Go语言内存管理的基本单元。</p>
<p>这里只列出了关心的主要字段。</p>
<ol>
<li><code>mspan</code>使用 <code>next</code>和<code>prev</code>指针构成双向链表</li>
<li><code>startAddr</code>确定了<code>mspan</code>所在内存的地址，<code>npages</code>确定了内存地址范围</li>
<li>每个<code>mspan</code>都管理这<code>npages</code>数量的page（注意这里的page不是操作系统的page，它是操作系统page的整数倍）</li>
<li><code>state</code>为<code>mspan</code>的状态，不细说。</li>
</ol>
<h3 id=spanclass>spanClass<a hidden class=anchor aria-hidden=true href=#spanclass>#</a></h3>
<p>这是<code>mspan</code>中一个很核心的字段，<code>spanClass</code>是跨度类，它决定了<code>mspan</code>中管理的存储对象的大小和个数。</p>
<p>Go语言中一共有68种跨度类，每个跨度类会存储特定大小的对象并且需要分配指定数量的page。</p>
<p><code>class_to_size</code>表示每个跨度类的字节大小。<br>
<code>class_to_allocnpages</code>表示每个跨度类需要分配page的数量。</p>
<p>ID为0的特殊跨度类，用于管理大对象。</p>
<p>跨度类的最后一个二进制位是<code>nospan</code>标记，即表示对象是否包含指针，用于加快垃圾回收。</p>
<p>每个<code>mspan</code>的内存都用于指定跨度类的内存分配。在分配内存时，首先需要选择最适合的跨度类，从而避免内存浪费。</p>
<h2 id=mcache>mcache<a hidden class=anchor aria-hidden=true href=#mcache>#</a></h2>
<p><code>mcache</code>是线程缓存，它和GMP模型中的P绑定，主要用于为用户小于32KB的微、小对象分配内存。</p>
<p>每个<code>mcache</code>有 $68 * 2$(<code>_NumSizeClasses &lt;&lt; 1</code>) 个 <code>mspan</code>。</p>
<p>上面我们说过跨度类共有68种，这里每个跨度类又分为<strong>有指针</strong>和<strong>无指针</strong>两类。</p>
<p>对于<strong>小对象</strong>，在<code>mcache</code>中，为对象寻找<code>mspan</code>的流程如下：</p>
<ol>
<li>计算对象所需内存大小<code>size</code></li>
<li>根据<code>size</code>到<code>size class</code>映射，计算出所需的<code>size class</code></li>
<li>根据<code>size class</code>和对象是否包含指针计算出<code>span class</code></li>
<li>获取该<code>span class</code>指向的<code>span</code>。</li>
</ol>
<p>但是如果对应的<code>mspan</code>没有剩余空间可被分配时，<code>mcache</code>就需要通过<code>refill()</code>函数向<code>mcentral</code>申请<code>mspan</code>,<code>mcache</code>拿到<code>mspan</code>后继续分配内存。</p>
<h2 id=mcentral>mcentral<a hidden class=anchor aria-hidden=true href=#mcentral>#</a></h2>
<p>每个中心缓存都会管理某个跨度类的内存管理单元，它会同时持有两个 runtime.spanSet，分别存储包含空闲对象和不包含空闲对象的内存管理单元。</p>
<p>当<code>mcentral</code>中的<code>span</code>不够用时，会找到<code>mheap</code>分配页数并获取新的<code>mspan</code>结构。</p>
<h2 id=mheap>mheap<a hidden class=anchor aria-hidden=true href=#mheap>#</a></h2>
<p><code>mheap</code>是内存分配的核心结构体，每个Go语言程序有一个对应的全局变量。</p>
<p>mheap包含两个重要部分，一个是<code>mcentral</code>数组，它管理所有的跨度类内存。另一个是管理堆内存区域的<code>arenas</code>。</p>
<p>Go 语言所有的内存空间都由如下所示的二维矩阵 <code>heapArena</code> 管理，这个二维矩阵管理的内存可以是不连续的，每一个 <code>heapArena</code> 都会管理 <code>64MB</code> 的操作系统的内存空间。</p>
<h1 id=内存分配>内存分配<a hidden class=anchor aria-hidden=true href=#内存分配>#</a></h1>
<ol>
<li>大于 32K 的大对象直接从 <code>mheap</code> 分配。</li>
<li>小于 16B 的使用 <code>mcache</code> 的微型分配器分配</li>
<li>对象大小在 16B ~ 32K 之间的的，首先通过计算使用的大小规格，然后使用 <code>mcache</code> 中对应大小规格的块分配</li>
<li>如果对应的大小规格在 <code>mcache</code> 中没有可用的块，则向 <code>mcentral</code> 申请</li>
<li>如果 <code>mcentral</code> 中没有可用的块，则向 <code>mheap</code> 申请，并根据 <code>BestFit</code> 算法找到最合适的 <code>mspan</code>。如果申请到的 <code>mspan</code> 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 <code>mspan</code> 放回 <code>mheap</code> 的空闲列表。</li>
<li>如果 <code>mheap</code> 中没有可用 <code>span</code>，则向操作系统申请一系列新的页（最小 1MB）。 Go 会在操作系统分配超大的页（称作 <code>arena</code>）。分配一大批页会减少和操作系统通信的成本</li>
</ol>
<h1 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h1>
<ol>
<li><a href=https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator>https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator</a></li>
<li><a href=https://qiankunli.github.io/2020/11/22/go_mm.html>https://qiankunli.github.io/2020/11/22/go_mm.html</a></li>
<li><a href=https://zhuanlan.zhihu.com/p/352133292>https://zhuanlan.zhihu.com/p/352133292</a></li>
<li><a href=https://www.linuxzen.com/go-memory-allocator-visual-guide.html>https://www.linuxzen.com/go-memory-allocator-visual-guide.html</a></li>
<li><a href=https://segmentfault.com/a/1190000039815122>https://segmentfault.com/a/1190000039815122</a></li>
<li><a href="https://segmentfault.com/a/1190000023869256?utm_source=sf-similar-article">https://segmentfault.com/a/1190000023869256?utm_source=sf-similar-article</a></li>
</ol>
</div>
<footer class=post-footer>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Go | 内存分配 on twitter" href="https://twitter.com/intent/tweet/?text=Go%20%7c%20%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d&url=https%3a%2f%2fzhangyh.me%2ftopics%2fgolang%2fgo-%25E5%2586%2585%25E5%25AD%2598%25E5%2588%2586%25E9%2585%258D.html&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Go | 内存分配 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fzhangyh.me%2ftopics%2fgolang%2fgo-%25E5%2586%2585%25E5%25AD%2598%25E5%2588%2586%25E9%2585%258D.html&title=Go%20%7c%20%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d&summary=Go%20%7c%20%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d&source=https%3a%2f%2fzhangyh.me%2ftopics%2fgolang%2fgo-%25E5%2586%2585%25E5%25AD%2598%25E5%2588%2586%25E9%2585%258D.html"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Go | 内存分配 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzhangyh.me%2ftopics%2fgolang%2fgo-%25E5%2586%2585%25E5%25AD%2598%25E5%2588%2586%25E9%2585%258D.html&title=Go%20%7c%20%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Go | 内存分配 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzhangyh.me%2ftopics%2fgolang%2fgo-%25E5%2586%2585%25E5%25AD%2598%25E5%2588%2586%25E9%2585%258D.html"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Go | 内存分配 on whatsapp" href="https://api.whatsapp.com/send?text=Go%20%7c%20%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%20-%20https%3a%2f%2fzhangyh.me%2ftopics%2fgolang%2fgo-%25E5%2586%2585%25E5%25AD%2598%25E5%2588%2586%25E9%2585%258D.html"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Go | 内存分配 on telegram" href="https://telegram.me/share/url?text=Go%20%7c%20%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d&url=https%3a%2f%2fzhangyh.me%2ftopics%2fgolang%2fgo-%25E5%2586%2585%25E5%25AD%2598%25E5%2588%2586%25E9%2585%258D.html"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://zhangyh.me/>yuler's blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>