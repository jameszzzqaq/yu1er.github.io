<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Redesigning LSMs for nonvolatile memory with NoveLSM | yuler's blog</title>
<meta name=keywords content>
<meta name=description content="Introduction 和目前的存储技术（例如flash、硬盘）相比， NVM有着以下的没有被LSM考虑的优点：
 对于持久存储的随机访问的高性能 in-place update的低成本 (具体是?) 低时延、高带宽为application-level的并行化提供了机会  作者认为探索redesign适用于NVM的LSM是有意义的，而不是design a new data structure。 基于以下考量：
 未来几年NVM和SSD共存，形成异质存储，而不是完全取代。redesign LSM可以在利用NVM的优点的前提下，同时不失去ssd和硬盘最优化的优势。 redesign lsm能为现有的应用提供向后兼容 保证批量写入NVM同样重要（NVM写延迟为DRAM的5-10倍）  Motivation 单纯的硬件NVM的读写是SSD的100倍左右，但在LevelDB在NVM和SSD上的差异只有4-7倍
因此可以说目前的LSM没有充分利用NVM的硬件优势，软件开销较大
Insert Latency insert latency来源有三个方面：
 WAL memtable insert compaction   对于compaction
内存中的mutable memtable在写满之后会刷新成immutable memtable，由后台进程将其压缩进磁盘，同时新开一个mutable memtable，来接管写入
问题是新的mutable memtable写满之后，如果immutable memtable还没有刷到磁盘内，就会造成系统的停顿
当进行大量的写入时，这会成为insert latency的主要来源。
 可能会说，让memtable大一点不就可以解决，但这会带来一系列的问题：
  增大memtable会带来双倍的内存占用，因为mutable memtable和immutable memtable需要同时增大
  WAL的磁盘占用也会更大，因为他需要容纳更多的指令
  LSM为了性能并不commit log。
> Third, LSMs suchas LevelDB and RocksDB do not enforce commits (sync) when writing to a log; as a result, an application crash or power-failure could lead to data loss">
<meta name=author content="yuler">
<link rel=canonical href=https://zhangyh.me/topics/paper/redesigning-lsms-for-nonvolatile-memory-with-novelsm.html>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.9f1d947375927e9847272b1f4e9be81336f539e513bf04d52cade31f81cad1af.css integrity="sha256-nx2Uc3WSfphHJysfTpvoEzb1OeUTvwTVLK3jH4HK0a8=" rel="preload stylesheet" as=style>
<link rel=preload href=/apple-touch-icon.png as=image>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="Redesigning LSMs for nonvolatile memory with NoveLSM">
<meta property="og:description" content="Introduction 和目前的存储技术（例如flash、硬盘）相比， NVM有着以下的没有被LSM考虑的优点：
 对于持久存储的随机访问的高性能 in-place update的低成本 (具体是?) 低时延、高带宽为application-level的并行化提供了机会  作者认为探索redesign适用于NVM的LSM是有意义的，而不是design a new data structure。 基于以下考量：
 未来几年NVM和SSD共存，形成异质存储，而不是完全取代。redesign LSM可以在利用NVM的优点的前提下，同时不失去ssd和硬盘最优化的优势。 redesign lsm能为现有的应用提供向后兼容 保证批量写入NVM同样重要（NVM写延迟为DRAM的5-10倍）  Motivation 单纯的硬件NVM的读写是SSD的100倍左右，但在LevelDB在NVM和SSD上的差异只有4-7倍
因此可以说目前的LSM没有充分利用NVM的硬件优势，软件开销较大
Insert Latency insert latency来源有三个方面：
 WAL memtable insert compaction   对于compaction
内存中的mutable memtable在写满之后会刷新成immutable memtable，由后台进程将其压缩进磁盘，同时新开一个mutable memtable，来接管写入
问题是新的mutable memtable写满之后，如果immutable memtable还没有刷到磁盘内，就会造成系统的停顿
当进行大量的写入时，这会成为insert latency的主要来源。
 可能会说，让memtable大一点不就可以解决，但这会带来一系列的问题：
  增大memtable会带来双倍的内存占用，因为mutable memtable和immutable memtable需要同时增大
  WAL的磁盘占用也会更大，因为他需要容纳更多的指令
  LSM为了性能并不commit log。
> Third, LSMs suchas LevelDB and RocksDB do not enforce commits (sync) when writing to a log; as a result, an application crash or power-failure could lead to data loss">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhangyh.me/topics/paper/redesigning-lsms-for-nonvolatile-memory-with-novelsm.html"><meta property="og:image" content="https://zhangyh.me/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-08-03T07:58:56+00:00">
<meta property="article:modified_time" content="2021-08-03T07:58:56+00:00"><meta property="og:site_name" content="ExampleSite">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhangyh.me/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="Redesigning LSMs for nonvolatile memory with NoveLSM">
<meta name=twitter:description content="Introduction 和目前的存储技术（例如flash、硬盘）相比， NVM有着以下的没有被LSM考虑的优点：
 对于持久存储的随机访问的高性能 in-place update的低成本 (具体是?) 低时延、高带宽为application-level的并行化提供了机会  作者认为探索redesign适用于NVM的LSM是有意义的，而不是design a new data structure。 基于以下考量：
 未来几年NVM和SSD共存，形成异质存储，而不是完全取代。redesign LSM可以在利用NVM的优点的前提下，同时不失去ssd和硬盘最优化的优势。 redesign lsm能为现有的应用提供向后兼容 保证批量写入NVM同样重要（NVM写延迟为DRAM的5-10倍）  Motivation 单纯的硬件NVM的读写是SSD的100倍左右，但在LevelDB在NVM和SSD上的差异只有4-7倍
因此可以说目前的LSM没有充分利用NVM的硬件优势，软件开销较大
Insert Latency insert latency来源有三个方面：
 WAL memtable insert compaction   对于compaction
内存中的mutable memtable在写满之后会刷新成immutable memtable，由后台进程将其压缩进磁盘，同时新开一个mutable memtable，来接管写入
问题是新的mutable memtable写满之后，如果immutable memtable还没有刷到磁盘内，就会造成系统的停顿
当进行大量的写入时，这会成为insert latency的主要来源。
 可能会说，让memtable大一点不就可以解决，但这会带来一系列的问题：
  增大memtable会带来双倍的内存占用，因为mutable memtable和immutable memtable需要同时增大
  WAL的磁盘占用也会更大，因为他需要容纳更多的指令
  LSM为了性能并不commit log。
> Third, LSMs suchas LevelDB and RocksDB do not enforce commits (sync) when writing to a log; as a result, an application crash or power-failure could lead to data loss">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zhangyh.me/posts/"},{"@type":"ListItem","position":2,"name":"Redesigning LSMs for nonvolatile memory with NoveLSM","item":"https://zhangyh.me/topics/paper/redesigning-lsms-for-nonvolatile-memory-with-novelsm.html"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redesigning LSMs for nonvolatile memory with NoveLSM","name":"Redesigning LSMs for nonvolatile memory with NoveLSM","description":"Introduction 和目前的存储技术（例如flash、硬盘）相比， NVM有着以下的没有被LSM考虑的优点：\n 对于持久存储的随机访问的高性能 in-place update的低成本 (具体是?) 低时延、高带宽为application-level的并行化提供了机会  作者认为探索redesign适用于NVM的LSM是有意义的，而不是design a new data structure。 基于以下考量：\n 未来几年NVM和SSD共存，形成异质存储，而不是完全取代。redesign LSM可以在利用NVM的优点的前提下，同时不失去ssd和硬盘最优化的优势。 redesign lsm能为现有的应用提供向后兼容 保证批量写入NVM同样重要（NVM写延迟为DRAM的5-10倍）  Motivation 单纯的硬件NVM的读写是SSD的100倍左右，但在LevelDB在NVM和SSD上的差异只有4-7倍\n因此可以说目前的LSM没有充分利用NVM的硬件优势，软件开销较大\nInsert Latency insert latency来源有三个方面：\n WAL memtable insert compaction   对于compaction\n内存中的mutable memtable在写满之后会刷新成immutable memtable，由后台进程将其压缩进磁盘，同时新开一个mutable memtable，来接管写入\n问题是新的mutable memtable写满之后，如果immutable memtable还没有刷到磁盘内，就会造成系统的停顿\n当进行大量的写入时，这会成为insert latency的主要来源。\n 可能会说，让memtable大一点不就可以解决，但这会带来一系列的问题：\n  增大memtable会带来双倍的内存占用，因为mutable memtable和immutable memtable需要同时增大\n  WAL的磁盘占用也会更大，因为他需要容纳更多的指令\n  LSM为了性能并不commit log。\n\u0026gt; Third, LSMs suchas LevelDB and RocksDB do not enforce commits (sync) when writing to a log; as a result, an application crash or power-failure could lead to data loss","keywords":[],"articleBody":"Introduction 和目前的存储技术（例如flash、硬盘）相比， NVM有着以下的没有被LSM考虑的优点：\n 对于持久存储的随机访问的高性能 in-place update的低成本 (具体是?) 低时延、高带宽为application-level的并行化提供了机会  作者认为探索redesign适用于NVM的LSM是有意义的，而不是design a new data structure。 基于以下考量：\n 未来几年NVM和SSD共存，形成异质存储，而不是完全取代。redesign LSM可以在利用NVM的优点的前提下，同时不失去ssd和硬盘最优化的优势。 redesign lsm能为现有的应用提供向后兼容 保证批量写入NVM同样重要（NVM写延迟为DRAM的5-10倍）  Motivation 单纯的硬件NVM的读写是SSD的100倍左右，但在LevelDB在NVM和SSD上的差异只有4-7倍\n因此可以说目前的LSM没有充分利用NVM的硬件优势，软件开销较大\nInsert Latency insert latency来源有三个方面：\n WAL memtable insert compaction   对于compaction\n内存中的mutable memtable在写满之后会刷新成immutable memtable，由后台进程将其压缩进磁盘，同时新开一个mutable memtable，来接管写入\n问题是新的mutable memtable写满之后，如果immutable memtable还没有刷到磁盘内，就会造成系统的停顿\n当进行大量的写入时，这会成为insert latency的主要来源。\n 可能会说，让memtable大一点不就可以解决，但这会带来一系列的问题：\n  增大memtable会带来双倍的内存占用，因为mutable memtable和immutable memtable需要同时增大\n  WAL的磁盘占用也会更大，因为他需要容纳更多的指令\n  LSM为了性能并不commit log。\n Third, LSMs suchas LevelDB and RocksDB do not enforce commits (sync) when writing to a log; as a result, an application crash or power-failure could lead to data loss\n  log更大导致故障恢复的时间更慢\n   Finally, the cost of checksumming and logging also increases\n   Read Latency read latency来源有:\n memtable read sstable index read (bloom filter加快搜索) sstable search (binary search, hierarchy) sstable data copy (将data block从磁盘拷贝到内存) sstable deserialize (将硬盘中的数据反序列化为内存中的数据格式)  Design NoveLSM Design Principles 原则1：利用byte-addressability，减少序列化和反序列化成本 原则2：利用mutability和large capacity，减少compaction成本 磁盘中数据需要先读入内存，操作后再写入磁盘。\nNVM中可以直接操作。\n原则3：利用in-place mutability，减少logging overhead和recovery cost 因为NVM的持久性，因此直接写入即可，不需要提前把日志持久化到磁盘\n原则4：利用low latency和high bandwidth，来并行化地读 Addressing (De)serialization Cost Immutable NVM skip list-based memtable. 设计immutable NVM skip list-based memtable，替代DRAM中的immutable memtable\nReducing Compaction Cost Mutability for persistent memtable 如图5b,交叉写入DRAM mutable memtable和large NVM mutable memtable\n 启动时首先初始化一个DRAM和NVM的mutable memtable 写入 DRAM mutable memtable，如果写满，冻结为immutable memtable，同时分配一个新的DRAM mutable memtable，同时将immutable memtable 进行compaction 刷入磁盘 写入 NVM mutable memtable，如果写满同上  也就是说\n留给每个compaction过程的时间为 = 写满一个DRAM mutable memtable + 写满一个NVM mutable memtable的时间\n因此也就大大减少了系统停滞的可能性\nReducing Logging Cost Logging 写入DRAM的同时需要记录日志（带来了写放大）\n写入NVM的直接in-place更新\nRecovery 故障时可能存在两种情况\n Vi写入DRAM memtable，但还没compaction\nVi+1正在写入NVM memtable Vi已经写入NVM memtable\nVi+1正在写入DRAM memtable  为了保证Recovery时的正确性：\n 对于每个DRAM memtable都有一个新的log file 正在写入NVM memtable时不需要log file，NVM memtable就可以被视作一个log file NVM log file有递增的version number  Recovery时按照version number递增顺序恢复\n发生故障时\n写入DRAM的需要从logging文件进行Recovery。\n写入NVM的memtable可以直接看作是一个日志文件，它同时需要一个存储跳表起始指针和其他元数据的额外文件从而在Recovery时定位数据。恢复时只需要进行内存映射即可。\nSupporting Read Parallelism Reducing read latency 常规的LSM中:\n使用一个线程自上向下mutable memtable - immutable memtable - SSTable\n在本设计中:\nDRAM memtable 和 NVM memtable使用一个线程\nDRAM immutable 和 NVM immutable使用一个线程\nSSTable使用一个线程\n因此时间从\n$T_{read} ≈ T_{mem_{DRAM}} + T_{mem_{NVM}} + T_{imm} + T_{SST} $\n压缩为\n$T_{read_parallel} ≈ max(T_{mem_{DRAM}} + T_{mem_{NVM}}, T_{imm}, T_{SST}) + C$\n$C$是常量，代表了找到结果后停止其他线程所需的时间\nGuaranteeing version correctness for reads. 更高层(memtable-immu-sstable)往往是最新的数据，版本号最新。\n 负责更高层的thread找到结果后停止其他线程 负责更低层的thread找到结果后，先等待更高层的执行完  Optimistic parallelism and management. 多线程也带来了管理成本\n 把多线程分配到不同的cpu上 为DRAM和NVM memtable添加bloom filter，只有bloom filter miss的时候，才开启多线程查询，否则就只使用单线程。  ","wordCount":"283","inLanguage":"en","datePublished":"2021-08-03T07:58:56Z","dateModified":"2021-08-03T07:58:56Z","author":{"@type":"Person","name":"yuler"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhangyh.me/topics/paper/redesigning-lsms-for-nonvolatile-memory-with-novelsm.html"},"publisher":{"@type":"Organization","name":"yuler's blog","logo":{"@type":"ImageObject","url":"https://zhangyh.me/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhangyh.me/ accesskey=h title="Home (Alt + H)">
<img src=/apple-touch-icon.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://zhangyh.me/categories/ title=categories>
<span>categories</span>
</a>
</li>
<li>
<a href=https://zhangyh.me/tags/ title=tags>
<span>tags</span>
</a>
</li>
<li>
<a href=https://zhangyh.me/archives/ title=archives>
<span>archives</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://zhangyh.me/>Home</a>&nbsp;»&nbsp;<a href=https://zhangyh.me/posts/>Posts</a></div>
<h1 class=post-title>
Redesigning LSMs for nonvolatile memory with NoveLSM
</h1>
<div class=post-meta>August 3, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;yuler&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/paper/2021-08-03-redesigning-lsms-for-nonvolatile-memory-with-novelsm.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header>
<div class=post-content><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1>
<p>和目前的存储技术（例如flash、硬盘）相比， NVM有着以下的没有被LSM考虑的优点：</p>
<ul>
<li>对于持久存储的<strong>随机访问</strong>的高性能</li>
<li>in-place update的低成本 (具体是?)</li>
<li>低时延、高带宽为application-level的并行化提供了机会</li>
</ul>
<p>作者认为探索redesign适用于NVM的LSM是有意义的，而不是design a new data structure。 基于以下考量：</p>
<ul>
<li>未来几年NVM和SSD共存，形成异质存储，而不是完全取代。redesign LSM可以在利用NVM的优点的前提下，同时不失去ssd和硬盘最优化的优势。</li>
<li>redesign lsm能为现有的应用提供向后兼容</li>
<li>保证批量写入NVM同样重要（NVM写延迟为DRAM的5-10倍）</li>
</ul>
<h1 id=motivation>Motivation<a hidden class=anchor aria-hidden=true href=#motivation>#</a></h1>
<p>单纯的硬件NVM的读写是SSD的100倍左右，但在LevelDB在NVM和SSD上的差异只有4-7倍<br>
因此可以说目前的LSM没有充分利用NVM的硬件优势，软件开销较大</p>
<h2 id=insert-latency>Insert Latency<a hidden class=anchor aria-hidden=true href=#insert-latency>#</a></h2>
<p>insert latency来源有三个方面：</p>
<ol>
<li><strong>WAL</strong></li>
<li>memtable insert</li>
<li><strong>compaction</strong></li>
</ol>
<blockquote>
<p>对于compaction<br>
内存中的mutable memtable在写满之后会刷新成immutable memtable，由后台进程将其压缩进磁盘，同时新开一个mutable memtable，来接管写入<br>
问题是新的mutable memtable写满之后，如果immutable memtable还没有刷到磁盘内，就会造成系统的停顿<br>
当进行大量的写入时，这会成为insert latency的主要来源。</p>
</blockquote>
<p>可能会说，让memtable大一点不就可以解决，但这会带来一系列的问题：</p>
<ol>
<li>
<p>增大memtable会带来双倍的内存占用，因为mutable memtable和immutable memtable需要同时增大</p>
</li>
<li>
<p>WAL的磁盘占用也会更大，因为他需要容纳更多的指令</p>
</li>
<li>
<p>LSM为了性能并不commit log。<br>
> Third, LSMs suchas LevelDB and RocksDB do not enforce commits (sync) when writing to a log; as a result, an application crash or power-failure could lead to data loss</p>
</li>
<li>
<p>log更大导致故障恢复的时间更慢</p>
</li>
<li>
<blockquote>
<p>Finally, the cost of checksumming and logging also increases</p>
</blockquote>
</li>
</ol>
<h2 id=read-latency>Read Latency<a hidden class=anchor aria-hidden=true href=#read-latency>#</a></h2>
<p>read latency来源有:</p>
<ol>
<li>memtable read</li>
<li>sstable index read (bloom filter加快搜索)</li>
<li><strong>sstable search (binary search, hierarchy)</strong></li>
<li>sstable data copy (将data block从磁盘拷贝到内存)</li>
<li><strong>sstable deserialize (将硬盘中的数据反序列化为内存中的数据格式)</strong></li>
</ol>
<h1 id=design>Design<a hidden class=anchor aria-hidden=true href=#design>#</a></h1>
<h2 id=novelsm-design-principles>NoveLSM Design Principles<a hidden class=anchor aria-hidden=true href=#novelsm-design-principles>#</a></h2>
<h3 id=原则1利用byte-addressability减少序列化和反序列化成本>原则1：利用byte-addressability，减少序列化和反序列化成本<a hidden class=anchor aria-hidden=true href=#原则1利用byte-addressability减少序列化和反序列化成本>#</a></h3>
<h3 id=原则2利用mutability和large-capacity减少compaction成本>原则2：利用mutability和large capacity，减少compaction成本<a hidden class=anchor aria-hidden=true href=#原则2利用mutability和large-capacity减少compaction成本>#</a></h3>
<p>磁盘中数据需要先读入内存，操作后再写入磁盘。<br>
NVM中可以直接操作。</p>
<h3 id=原则3利用in-place-mutability减少logging-overhead和recovery-cost>原则3：利用in-place mutability，减少logging overhead和recovery cost<a hidden class=anchor aria-hidden=true href=#原则3利用in-place-mutability减少logging-overhead和recovery-cost>#</a></h3>
<p>因为NVM的持久性，因此直接写入即可，不需要提前把日志持久化到磁盘</p>
<h3 id=原则4利用low-latency和high-bandwidth来并行化地读>原则4：利用low latency和high bandwidth，来并行化地读<a hidden class=anchor aria-hidden=true href=#原则4利用low-latency和high-bandwidth来并行化地读>#</a></h3>
<h2 id=addressing-deserialization-cost>Addressing (De)serialization Cost<a hidden class=anchor aria-hidden=true href=#addressing-deserialization-cost>#</a></h2>
<h3 id=immutable-nvm-skip-list-based-memtable>Immutable NVM skip list-based memtable.<a hidden class=anchor aria-hidden=true href=#immutable-nvm-skip-list-based-memtable>#</a></h3>
<p>设计immutable NVM skip list-based memtable，替代DRAM中的immutable memtable</p>
<h2 id=reducing-compaction-cost>Reducing Compaction Cost<a hidden class=anchor aria-hidden=true href=#reducing-compaction-cost>#</a></h2>
<h3 id=mutability-for-persistent-memtable>Mutability for persistent memtable<a hidden class=anchor aria-hidden=true href=#mutability-for-persistent-memtable>#</a></h3>
<p>如图5b,交叉写入DRAM mutable memtable和large NVM mutable memtable</p>
<ol>
<li>启动时首先初始化一个DRAM和NVM的mutable memtable</li>
<li>写入 DRAM mutable memtable，如果写满，冻结为immutable memtable，同时分配一个新的DRAM mutable memtable，同时将immutable memtable 进行compaction 刷入磁盘</li>
<li>写入 NVM mutable memtable，如果写满同上</li>
</ol>
<p>也就是说<br>
留给每个compaction过程的时间为 = 写满一个DRAM mutable memtable + 写满一个NVM mutable memtable的时间</p>
<p>因此也就大大减少了系统停滞的可能性</p>
<h2 id=reducing-logging-cost>Reducing Logging Cost<a hidden class=anchor aria-hidden=true href=#reducing-logging-cost>#</a></h2>
<h3 id=logging>Logging<a hidden class=anchor aria-hidden=true href=#logging>#</a></h3>
<p>写入DRAM的同时需要记录日志（带来了写放大）<br>
写入NVM的直接in-place更新</p>
<h3 id=recovery>Recovery<a hidden class=anchor aria-hidden=true href=#recovery>#</a></h3>
<p>故障时可能存在两种情况</p>
<ol>
<li>Vi写入DRAM memtable，但还没compaction<br>
Vi+1正在写入NVM memtable</li>
<li>Vi已经写入NVM memtable<br>
Vi+1正在写入DRAM memtable</li>
</ol>
<p>为了保证Recovery时的正确性：</p>
<ol>
<li>对于每个DRAM memtable都有一个新的log file</li>
<li>正在写入NVM memtable时不需要log file，NVM memtable就可以被视作一个log file</li>
<li>NVM log file有递增的version number</li>
</ol>
<p>Recovery时按照version number递增顺序恢复</p>
<p>发生故障时<br>
写入DRAM的需要从logging文件进行Recovery。<br>
写入NVM的memtable可以直接看作是一个日志文件，它同时需要一个存储跳表起始指针和其他元数据的额外文件从而在Recovery时定位数据。恢复时只需要进行内存映射即可。</p>
<h2 id=supporting-read-parallelism>Supporting Read Parallelism<a hidden class=anchor aria-hidden=true href=#supporting-read-parallelism>#</a></h2>
<h3 id=reducing-read-latency>Reducing read latency<a hidden class=anchor aria-hidden=true href=#reducing-read-latency>#</a></h3>
<p>常规的LSM中:<br>
使用一个线程自上向下mutable memtable -> immutable memtable -> SSTable<br>
在本设计中:<br>
DRAM memtable 和 NVM memtable使用一个线程<br>
DRAM immutable 和 NVM immutable使用一个线程<br>
SSTable使用一个线程</p>
<p>因此时间从<br>
$T_{read} ≈ T_{mem_{DRAM}} + T_{mem_{NVM}} + T_{imm} + T_{SST} $<br>
压缩为<br>
$T_{read_parallel} ≈ max(T_{mem_{DRAM}} + T_{mem_{NVM}}, T_{imm}, T_{SST}) + C$<br>
$C$是常量，代表了找到结果后停止其他线程所需的时间</p>
<h3 id=guaranteeing-version-correctness-for-reads>Guaranteeing version correctness for reads.<a hidden class=anchor aria-hidden=true href=#guaranteeing-version-correctness-for-reads>#</a></h3>
<p>更高层(memtable->immu->sstable)往往是最新的数据，版本号最新。</p>
<ul>
<li>负责更高层的thread找到结果后停止其他线程</li>
<li>负责更低层的thread找到结果后，先等待更高层的执行完</li>
</ul>
<h3 id=optimistic-parallelism-and-management>Optimistic parallelism and management.<a hidden class=anchor aria-hidden=true href=#optimistic-parallelism-and-management>#</a></h3>
<p>多线程也带来了管理成本</p>
<ul>
<li>把多线程分配到不同的cpu上</li>
<li>为DRAM和NVM memtable添加bloom filter，只有bloom filter miss的时候，才开启多线程查询，否则就只使用单线程。</li>
</ul>
</div>
<footer class=post-footer>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Redesigning LSMs for nonvolatile memory with NoveLSM on twitter" href="https://twitter.com/intent/tweet/?text=Redesigning%20LSMs%20for%20nonvolatile%20memory%20with%20NoveLSM&url=https%3a%2f%2fzhangyh.me%2ftopics%2fpaper%2fredesigning-lsms-for-nonvolatile-memory-with-novelsm.html&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Redesigning LSMs for nonvolatile memory with NoveLSM on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fzhangyh.me%2ftopics%2fpaper%2fredesigning-lsms-for-nonvolatile-memory-with-novelsm.html&title=Redesigning%20LSMs%20for%20nonvolatile%20memory%20with%20NoveLSM&summary=Redesigning%20LSMs%20for%20nonvolatile%20memory%20with%20NoveLSM&source=https%3a%2f%2fzhangyh.me%2ftopics%2fpaper%2fredesigning-lsms-for-nonvolatile-memory-with-novelsm.html"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Redesigning LSMs for nonvolatile memory with NoveLSM on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzhangyh.me%2ftopics%2fpaper%2fredesigning-lsms-for-nonvolatile-memory-with-novelsm.html&title=Redesigning%20LSMs%20for%20nonvolatile%20memory%20with%20NoveLSM"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Redesigning LSMs for nonvolatile memory with NoveLSM on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzhangyh.me%2ftopics%2fpaper%2fredesigning-lsms-for-nonvolatile-memory-with-novelsm.html"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Redesigning LSMs for nonvolatile memory with NoveLSM on whatsapp" href="https://api.whatsapp.com/send?text=Redesigning%20LSMs%20for%20nonvolatile%20memory%20with%20NoveLSM%20-%20https%3a%2f%2fzhangyh.me%2ftopics%2fpaper%2fredesigning-lsms-for-nonvolatile-memory-with-novelsm.html"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Redesigning LSMs for nonvolatile memory with NoveLSM on telegram" href="https://telegram.me/share/url?text=Redesigning%20LSMs%20for%20nonvolatile%20memory%20with%20NoveLSM&url=https%3a%2f%2fzhangyh.me%2ftopics%2fpaper%2fredesigning-lsms-for-nonvolatile-memory-with-novelsm.html"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://zhangyh.me/>yuler's blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>