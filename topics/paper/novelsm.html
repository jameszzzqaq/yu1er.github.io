<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Redesigning LSMs for nonvolatile memory with NoveLSM | yuler's blog</title>
<meta name=keywords content="LSM-Tree,NVM">
<meta name=description content="Introduction 和目前的存储技术（例如flash、硬盘）相比， NVM有着以下的没有被LSM考虑的优点：
 对于持久存储的随机访问的高性能 in-place update的低成本 (具体是?) 低时延、高带宽为application-level的并行化提供了机会  作者认为探索redesign适用于NVM的LSM是有意义的，而不是design a new data structure。 基于以下考量：
 未来几年NVM和SSD共存，形成异质存储，而不是完全取代。redesign LSM可以在利用NVM的优点的前提下，同时不失去ssd和硬盘最优化的优势。 redesign lsm能为现有的应用提供向后兼容 保证批量写入NVM同样重要（NVM写延迟为DRAM的5-10倍）  Motivation 单纯的硬件NVM的读写是SSD的100倍左右，但在LevelDB在NVM和SSD上的差异只有4-7倍 因此可以说目前的LSM没有充分利用NVM的硬件优势，软件开销较大
Insert Latency insert latency来源有三个方面：
 WAL memtable insert compaction   对于compaction 内存中的mutable memtable在写满之后会刷新成immutable memtable，由后台进程将其压缩进磁盘，同时新开一个mutable memtable，来接管写入 问题是新的mutable memtable写满之后，如果immutable memtable还没有刷到磁盘内，就会造成系统的停顿 当进行大量的写入时，这会成为insert latency的主要来源。
 可能会说，让memtable大一点不就可以解决，但这会带来一系列的问题：
 增大memtable会带来双倍的内存占用，因为mutable memtable和immutable memtable需要同时增大 WAL的磁盘占用也会更大，因为他需要容纳更多的指令 LSM为了性能并不commit log。   Third, LSMs suchas LevelDB and RocksDB do not enforce commits (sync) when writing to a log; as a result, an application crash or power-failure could lead to data loss">
<meta name=author content="yuler">
<link rel=canonical href=https://zhangyh.me/topics/paper/novelsm.html>
<meta name=google-site-verification content="G-JP3WQ36T5K">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabcsadf">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style>
<link rel=icon href=https://zhangyh.me/icon/jiaran16.ico>
<link rel=icon type=image/png sizes=16x16 href=https://zhangyh.me/icon/jiaran16.ico>
<link rel=icon type=image/png sizes=32x32 href=https://zhangyh.me/icon/jiaran32.ico>
<link rel=apple-touch-icon href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://zhangyh.me/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.89.4">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JP3WQ36T5K"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JP3WQ36T5K',{anonymize_ip:!1})}</script>
<meta property="og:title" content="Redesigning LSMs for nonvolatile memory with NoveLSM">
<meta property="og:description" content="Introduction 和目前的存储技术（例如flash、硬盘）相比， NVM有着以下的没有被LSM考虑的优点：
 对于持久存储的随机访问的高性能 in-place update的低成本 (具体是?) 低时延、高带宽为application-level的并行化提供了机会  作者认为探索redesign适用于NVM的LSM是有意义的，而不是design a new data structure。 基于以下考量：
 未来几年NVM和SSD共存，形成异质存储，而不是完全取代。redesign LSM可以在利用NVM的优点的前提下，同时不失去ssd和硬盘最优化的优势。 redesign lsm能为现有的应用提供向后兼容 保证批量写入NVM同样重要（NVM写延迟为DRAM的5-10倍）  Motivation 单纯的硬件NVM的读写是SSD的100倍左右，但在LevelDB在NVM和SSD上的差异只有4-7倍 因此可以说目前的LSM没有充分利用NVM的硬件优势，软件开销较大
Insert Latency insert latency来源有三个方面：
 WAL memtable insert compaction   对于compaction 内存中的mutable memtable在写满之后会刷新成immutable memtable，由后台进程将其压缩进磁盘，同时新开一个mutable memtable，来接管写入 问题是新的mutable memtable写满之后，如果immutable memtable还没有刷到磁盘内，就会造成系统的停顿 当进行大量的写入时，这会成为insert latency的主要来源。
 可能会说，让memtable大一点不就可以解决，但这会带来一系列的问题：
 增大memtable会带来双倍的内存占用，因为mutable memtable和immutable memtable需要同时增大 WAL的磁盘占用也会更大，因为他需要容纳更多的指令 LSM为了性能并不commit log。   Third, LSMs suchas LevelDB and RocksDB do not enforce commits (sync) when writing to a log; as a result, an application crash or power-failure could lead to data loss">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhangyh.me/topics/paper/novelsm.html"><meta property="og:image" content="https://zhangyh.me/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-08-03T00:00:00+00:00">
<meta property="article:modified_time" content="2021-08-03T00:00:00+00:00"><meta property="og:site_name" content="yuler's blog">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhangyh.me/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="Redesigning LSMs for nonvolatile memory with NoveLSM">
<meta name=twitter:description content="Introduction 和目前的存储技术（例如flash、硬盘）相比， NVM有着以下的没有被LSM考虑的优点：
 对于持久存储的随机访问的高性能 in-place update的低成本 (具体是?) 低时延、高带宽为application-level的并行化提供了机会  作者认为探索redesign适用于NVM的LSM是有意义的，而不是design a new data structure。 基于以下考量：
 未来几年NVM和SSD共存，形成异质存储，而不是完全取代。redesign LSM可以在利用NVM的优点的前提下，同时不失去ssd和硬盘最优化的优势。 redesign lsm能为现有的应用提供向后兼容 保证批量写入NVM同样重要（NVM写延迟为DRAM的5-10倍）  Motivation 单纯的硬件NVM的读写是SSD的100倍左右，但在LevelDB在NVM和SSD上的差异只有4-7倍 因此可以说目前的LSM没有充分利用NVM的硬件优势，软件开销较大
Insert Latency insert latency来源有三个方面：
 WAL memtable insert compaction   对于compaction 内存中的mutable memtable在写满之后会刷新成immutable memtable，由后台进程将其压缩进磁盘，同时新开一个mutable memtable，来接管写入 问题是新的mutable memtable写满之后，如果immutable memtable还没有刷到磁盘内，就会造成系统的停顿 当进行大量的写入时，这会成为insert latency的主要来源。
 可能会说，让memtable大一点不就可以解决，但这会带来一系列的问题：
 增大memtable会带来双倍的内存占用，因为mutable memtable和immutable memtable需要同时增大 WAL的磁盘占用也会更大，因为他需要容纳更多的指令 LSM为了性能并不commit log。   Third, LSMs suchas LevelDB and RocksDB do not enforce commits (sync) when writing to a log; as a result, an application crash or power-failure could lead to data loss">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zhangyh.me/posts/"},{"@type":"ListItem","position":2,"name":"Redesigning LSMs for nonvolatile memory with NoveLSM","item":"https://zhangyh.me/topics/paper/novelsm.html"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redesigning LSMs for nonvolatile memory with NoveLSM","name":"Redesigning LSMs for nonvolatile memory with NoveLSM","description":"Introduction 和目前的存储技术（例如flash、硬盘）相比， NVM有着以下的没有被LSM考虑的优点：\n 对于持久存储的随机访问的高性能 in-place update的低成本 (具体是?) 低时延、高带宽为application-level的并行化提供了机会  作者认为探索redesign适用于NVM的LSM是有意义的，而不是design a new data structure。 基于以下考量：\n 未来几年NVM和SSD共存，形成异质存储，而不是完全取代。redesign LSM可以在利用NVM的优点的前提下，同时不失去ssd和硬盘最优化的优势。 redesign lsm能为现有的应用提供向后兼容 保证批量写入NVM同样重要（NVM写延迟为DRAM的5-10倍）  Motivation 单纯的硬件NVM的读写是SSD的100倍左右，但在LevelDB在NVM和SSD上的差异只有4-7倍 因此可以说目前的LSM没有充分利用NVM的硬件优势，软件开销较大\nInsert Latency insert latency来源有三个方面：\n WAL memtable insert compaction   对于compaction 内存中的mutable memtable在写满之后会刷新成immutable memtable，由后台进程将其压缩进磁盘，同时新开一个mutable memtable，来接管写入 问题是新的mutable memtable写满之后，如果immutable memtable还没有刷到磁盘内，就会造成系统的停顿 当进行大量的写入时，这会成为insert latency的主要来源。\n 可能会说，让memtable大一点不就可以解决，但这会带来一系列的问题：\n 增大memtable会带来双倍的内存占用，因为mutable memtable和immutable memtable需要同时增大 WAL的磁盘占用也会更大，因为他需要容纳更多的指令 LSM为了性能并不commit log。   Third, LSMs suchas LevelDB and RocksDB do not enforce commits (sync) when writing to a log; as a result, an application crash or power-failure could lead to data loss","keywords":["LSM-Tree","NVM"],"articleBody":"Introduction 和目前的存储技术（例如flash、硬盘）相比， NVM有着以下的没有被LSM考虑的优点：\n 对于持久存储的随机访问的高性能 in-place update的低成本 (具体是?) 低时延、高带宽为application-level的并行化提供了机会  作者认为探索redesign适用于NVM的LSM是有意义的，而不是design a new data structure。 基于以下考量：\n 未来几年NVM和SSD共存，形成异质存储，而不是完全取代。redesign LSM可以在利用NVM的优点的前提下，同时不失去ssd和硬盘最优化的优势。 redesign lsm能为现有的应用提供向后兼容 保证批量写入NVM同样重要（NVM写延迟为DRAM的5-10倍）  Motivation 单纯的硬件NVM的读写是SSD的100倍左右，但在LevelDB在NVM和SSD上的差异只有4-7倍 因此可以说目前的LSM没有充分利用NVM的硬件优势，软件开销较大\nInsert Latency insert latency来源有三个方面：\n WAL memtable insert compaction   对于compaction 内存中的mutable memtable在写满之后会刷新成immutable memtable，由后台进程将其压缩进磁盘，同时新开一个mutable memtable，来接管写入 问题是新的mutable memtable写满之后，如果immutable memtable还没有刷到磁盘内，就会造成系统的停顿 当进行大量的写入时，这会成为insert latency的主要来源。\n 可能会说，让memtable大一点不就可以解决，但这会带来一系列的问题：\n 增大memtable会带来双倍的内存占用，因为mutable memtable和immutable memtable需要同时增大 WAL的磁盘占用也会更大，因为他需要容纳更多的指令 LSM为了性能并不commit log。   Third, LSMs suchas LevelDB and RocksDB do not enforce commits (sync) when writing to a log; as a result, an application crash or power-failure could lead to data loss\n log更大导致故障恢复的时间更慢   Finally, the cost of checksumming and logging also increases\n   Read Latency read latency来源有:\n memtable read sstable index read (bloom filter加快搜索) sstable search (binary search, hierarchy) sstable data copy (将data block从磁盘拷贝到内存) sstable deserialize (将硬盘中的数据反序列化为内存中的数据格式)  Design NoveLSM Design Principles 原则1：利用byte-addressability，减少序列化和反序列化成本 原则2：利用mutability和large capacity，减少compaction成本 磁盘中数据需要先读入内存，操作后再写入磁盘。 NVM中可以直接操作。\n原则3：利用in-place mutability，减少logging overhead和recovery cost 因为NVM的持久性，因此直接写入即可，不需要提前把日志持久化到磁盘\n原则4：利用low latency和high bandwidth，来并行化地读 Addressing (De)serialization Cost Immutable NVM skip list-based memtable. 设计immutable NVM skip list-based memtable，替代DRAM中的immutable memtable\nReducing Compaction Cost Mutability for persistent memtable 如图5b,交叉写入DRAM mutable memtable和large NVM mutable memtable\n 启动时首先初始化一个DRAM和NVM的mutable memtable 写入 DRAM mutable memtable，如果写满，冻结为immutable memtable，同时分配一个新的DRAM mutable memtable，同时将immutable memtable 进行compaction 刷入磁盘 写入 NVM mutable memtable，如果写满同上  也就是说 留给每个compaction过程的时间为 = 写满一个DRAM mutable memtable + 写满一个NVM mutable memtable的时间\n因此也就大大减少了系统停滞的可能性\nReducing Logging Cost Logging 写入DRAM的同时需要记录日志（带来了写放大） 写入NVM的直接in-place更新\nRecovery 故障时可能存在两种情况\n Vi写入DRAM memtable，但还没compaction Vi+1正在写入NVM memtable Vi已经写入NVM memtable Vi+1正在写入DRAM memtable  为了保证Recovery时的正确性：\n 对于每个DRAM memtable都有一个新的log file 正在写入NVM memtable时不需要log file，NVM memtable就可以被视作一个log file NVM log file有递增的version number  Recovery时按照version number递增顺序恢复\n发生故障时 写入DRAM的需要从logging文件进行Recovery。 写入NVM的memtable可以直接看作是一个日志文件，它同时需要一个存储跳表起始指针和其他元数据的额外文件从而在Recovery时定位数据。恢复时只需要进行内存映射即可。\nSupporting Read Parallelism Reducing read latency 常规的LSM中: 使用一个线程自上向下mutable memtable - immutable memtable - SSTable 在本设计中: DRAM memtable 和 NVM memtable使用一个线程 DRAM immutable 和 NVM immutable使用一个线程 SSTable使用一个线程\n因此时间从 $T_{read} ≈ T_{mem_{DRAM}} + T_{mem_{NVM}} + T_{imm} + T_{SST} $ 压缩为 $T_{read_parallel} ≈ max(T_{mem_{DRAM}} + T_{mem_{NVM}}, T_{imm}, T_{SST}) + C$ $C$是常量，代表了找到结果后停止其他线程所需的时间\nGuaranteeing version correctness for reads. 更高层(memtable-immu-sstable)往往是最新的数据，版本号最新。\n 负责更高层的thread找到结果后停止其他线程 负责更低层的thread找到结果后，先等待更高层的执行完  Optimistic parallelism and management. 多线程也带来了管理成本\n 把多线程分配到不同的cpu上 为DRAM和NVM memtable添加bloom filter，只有bloom filter miss的时候，才开启多线程查询，否则就只使用单线程。  ","wordCount":"282","inLanguage":"en","datePublished":"2021-08-03T00:00:00Z","dateModified":"2021-08-03T00:00:00Z","author":{"@type":"Person","name":"yuler"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhangyh.me/topics/paper/novelsm.html"},"publisher":{"@type":"Organization","name":"yuler's blog","logo":{"@type":"ImageObject","url":"https://zhangyh.me/icon/jiaran16.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhangyh.me/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://zhangyh.me/archives/ title=archives>
<span>archives</span>
</a>
</li>
<li>
<a href=https://zhangyh.me/categories/ title=categories>
<span>categories</span>
</a>
</li>
<li>
<a href=https://zhangyh.me/tags/ title=tags>
<span>tags</span>
</a>
</li>
<li>
<a href=https://zhangyh.me/search/ title="search (Alt + /)" accesskey=/>
<span>search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://zhangyh.me/>Home</a>&nbsp;»&nbsp;<a href=https://zhangyh.me/posts/>Posts</a></div>
<h1 class=post-title>
Redesigning LSMs for nonvolatile memory with NoveLSM
</h1>
<div class=post-meta>8-3&nbsp;·&nbsp;yuler&nbsp;|&nbsp;<a href=https://github.com/yu1er/blog-src/tree/main/content/posts/paper/21-8/Novelsm.md rel="noopener noreferrer" target=_blank>Edit</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#introduction aria-label=Introduction>Introduction</a></li>
<li>
<a href=#motivation aria-label=Motivation>Motivation</a><ul>
<li>
<a href=#insert-latency aria-label="Insert Latency">Insert Latency</a></li>
<li>
<a href=#read-latency aria-label="Read Latency">Read Latency</a></li></ul>
</li>
<li>
<a href=#design aria-label=Design>Design</a><ul>
<li>
<a href=#novelsm-design-principles aria-label="NoveLSM Design Principles">NoveLSM Design Principles</a><ul>
<li>
<a href=#%e5%8e%9f%e5%88%991%e5%88%a9%e7%94%a8byte-addressability%e5%87%8f%e5%b0%91%e5%ba%8f%e5%88%97%e5%8c%96%e5%92%8c%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%88%90%e6%9c%ac aria-label=原则1：利用byte-addressability，减少序列化和反序列化成本>原则1：利用byte-addressability，减少序列化和反序列化成本</a></li>
<li>
<a href=#%e5%8e%9f%e5%88%992%e5%88%a9%e7%94%a8mutability%e5%92%8clarge-capacity%e5%87%8f%e5%b0%91compaction%e6%88%90%e6%9c%ac aria-label="原则2：利用mutability和large capacity，减少compaction成本">原则2：利用mutability和large capacity，减少compaction成本</a></li>
<li>
<a href=#%e5%8e%9f%e5%88%993%e5%88%a9%e7%94%a8in-place-mutability%e5%87%8f%e5%b0%91logging-overhead%e5%92%8crecovery-cost aria-label="原则3：利用in-place mutability，减少logging overhead和recovery cost">原则3：利用in-place mutability，减少logging overhead和recovery cost</a></li>
<li>
<a href=#%e5%8e%9f%e5%88%994%e5%88%a9%e7%94%a8low-latency%e5%92%8chigh-bandwidth%e6%9d%a5%e5%b9%b6%e8%a1%8c%e5%8c%96%e5%9c%b0%e8%af%bb aria-label="原则4：利用low latency和high bandwidth，来并行化地读">原则4：利用low latency和high bandwidth，来并行化地读</a></li></ul>
</li>
<li>
<a href=#addressing-deserialization-cost aria-label="Addressing (De)serialization Cost">Addressing (De)serialization Cost</a><ul>
<li>
<a href=#immutable-nvm-skip-list-based-memtable aria-label="Immutable NVM skip list-based memtable.">Immutable NVM skip list-based memtable.</a></li></ul>
</li>
<li>
<a href=#reducing-compaction-cost aria-label="Reducing Compaction Cost">Reducing Compaction Cost</a><ul>
<li>
<a href=#mutability-for-persistent-memtable aria-label="Mutability for persistent memtable">Mutability for persistent memtable</a></li></ul>
</li>
<li>
<a href=#reducing-logging-cost aria-label="Reducing Logging Cost">Reducing Logging Cost</a><ul>
<li>
<a href=#logging aria-label=Logging>Logging</a></li>
<li>
<a href=#recovery aria-label=Recovery>Recovery</a></li></ul>
</li>
<li>
<a href=#supporting-read-parallelism aria-label="Supporting Read Parallelism">Supporting Read Parallelism</a><ul>
<li>
<a href=#reducing-read-latency aria-label="Reducing read latency">Reducing read latency</a></li>
<li>
<a href=#guaranteeing-version-correctness-for-reads aria-label="Guaranteeing version correctness for reads.">Guaranteeing version correctness for reads.</a></li>
<li>
<a href=#optimistic-parallelism-and-management aria-label="Optimistic parallelism and management.">Optimistic parallelism and management.</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1>
<p>和目前的存储技术（例如flash、硬盘）相比， NVM有着以下的没有被LSM考虑的优点：</p>
<ul>
<li>对于持久存储的<strong>随机访问</strong>的高性能</li>
<li>in-place update的低成本 (具体是?)</li>
<li>低时延、高带宽为application-level的并行化提供了机会</li>
</ul>
<p>作者认为探索redesign适用于NVM的LSM是有意义的，而不是design a new data structure。 基于以下考量：</p>
<ul>
<li>未来几年NVM和SSD共存，形成异质存储，而不是完全取代。redesign LSM可以在利用NVM的优点的前提下，同时不失去ssd和硬盘最优化的优势。</li>
<li>redesign lsm能为现有的应用提供向后兼容</li>
<li>保证批量写入NVM同样重要（NVM写延迟为DRAM的5-10倍）</li>
</ul>
<h1 id=motivation>Motivation<a hidden class=anchor aria-hidden=true href=#motivation>#</a></h1>
<p>单纯的硬件NVM的读写是SSD的100倍左右，但在LevelDB在NVM和SSD上的差异只有4-7倍
因此可以说目前的LSM没有充分利用NVM的硬件优势，软件开销较大</p>
<h2 id=insert-latency>Insert Latency<a hidden class=anchor aria-hidden=true href=#insert-latency>#</a></h2>
<p>insert latency来源有三个方面：</p>
<ol>
<li><strong>WAL</strong></li>
<li>memtable insert</li>
<li><strong>compaction</strong></li>
</ol>
<blockquote>
<p>对于compaction
内存中的mutable memtable在写满之后会刷新成immutable memtable，由后台进程将其压缩进磁盘，同时新开一个mutable memtable，来接管写入
问题是新的mutable memtable写满之后，如果immutable memtable还没有刷到磁盘内，就会造成系统的停顿
当进行大量的写入时，这会成为insert latency的主要来源。</p>
</blockquote>
<p>可能会说，让memtable大一点不就可以解决，但这会带来一系列的问题：</p>
<ol>
<li>增大memtable会带来双倍的内存占用，因为mutable memtable和immutable memtable需要同时增大</li>
<li>WAL的磁盘占用也会更大，因为他需要容纳更多的指令</li>
<li>LSM为了性能并不commit log。</li>
</ol>
<blockquote>
<p>Third, LSMs suchas LevelDB and RocksDB do not enforce commits (sync) when writing to a log; as a result, an application crash or power-failure could lead to data loss</p>
</blockquote>
<ol start=4>
<li>log更大导致故障恢复的时间更慢</li>
<li>
<blockquote>
<p>Finally, the cost of checksumming and logging also increases</p>
</blockquote>
</li>
</ol>
<h2 id=read-latency>Read Latency<a hidden class=anchor aria-hidden=true href=#read-latency>#</a></h2>
<p>read latency来源有:</p>
<ol>
<li>memtable read</li>
<li>sstable index read (bloom filter加快搜索)</li>
<li><strong>sstable search (binary search, hierarchy)</strong></li>
<li>sstable data copy (将data block从磁盘拷贝到内存)</li>
<li><strong>sstable deserialize (将硬盘中的数据反序列化为内存中的数据格式)</strong></li>
</ol>
<h1 id=design>Design<a hidden class=anchor aria-hidden=true href=#design>#</a></h1>
<p><img loading=lazy src=/img/novelsm.webp alt>
</p>
<h2 id=novelsm-design-principles>NoveLSM Design Principles<a hidden class=anchor aria-hidden=true href=#novelsm-design-principles>#</a></h2>
<h3 id=原则1利用byte-addressability减少序列化和反序列化成本>原则1：利用byte-addressability，减少序列化和反序列化成本<a hidden class=anchor aria-hidden=true href=#原则1利用byte-addressability减少序列化和反序列化成本>#</a></h3>
<h3 id=原则2利用mutability和large-capacity减少compaction成本>原则2：利用mutability和large capacity，减少compaction成本<a hidden class=anchor aria-hidden=true href=#原则2利用mutability和large-capacity减少compaction成本>#</a></h3>
<p>磁盘中数据需要先读入内存，操作后再写入磁盘。
NVM中可以直接操作。</p>
<h3 id=原则3利用in-place-mutability减少logging-overhead和recovery-cost>原则3：利用in-place mutability，减少logging overhead和recovery cost<a hidden class=anchor aria-hidden=true href=#原则3利用in-place-mutability减少logging-overhead和recovery-cost>#</a></h3>
<p>因为NVM的持久性，因此直接写入即可，不需要提前把日志持久化到磁盘</p>
<h3 id=原则4利用low-latency和high-bandwidth来并行化地读>原则4：利用low latency和high bandwidth，来并行化地读<a hidden class=anchor aria-hidden=true href=#原则4利用low-latency和high-bandwidth来并行化地读>#</a></h3>
<h2 id=addressing-deserialization-cost>Addressing (De)serialization Cost<a hidden class=anchor aria-hidden=true href=#addressing-deserialization-cost>#</a></h2>
<h3 id=immutable-nvm-skip-list-based-memtable>Immutable NVM skip list-based memtable.<a hidden class=anchor aria-hidden=true href=#immutable-nvm-skip-list-based-memtable>#</a></h3>
<p>设计immutable NVM skip list-based memtable，替代DRAM中的immutable memtable</p>
<h2 id=reducing-compaction-cost>Reducing Compaction Cost<a hidden class=anchor aria-hidden=true href=#reducing-compaction-cost>#</a></h2>
<h3 id=mutability-for-persistent-memtable>Mutability for persistent memtable<a hidden class=anchor aria-hidden=true href=#mutability-for-persistent-memtable>#</a></h3>
<p>如图5b,交叉写入DRAM mutable memtable和large NVM mutable memtable</p>
<ol>
<li>启动时首先初始化一个DRAM和NVM的mutable memtable</li>
<li>写入 DRAM mutable memtable，如果写满，冻结为immutable memtable，同时分配一个新的DRAM mutable memtable，同时将immutable memtable 进行compaction 刷入磁盘</li>
<li>写入 NVM mutable memtable，如果写满同上</li>
</ol>
<p>也就是说
留给每个compaction过程的时间为 = 写满一个DRAM mutable memtable + 写满一个NVM mutable memtable的时间</p>
<p>因此也就大大减少了系统停滞的可能性</p>
<h2 id=reducing-logging-cost>Reducing Logging Cost<a hidden class=anchor aria-hidden=true href=#reducing-logging-cost>#</a></h2>
<h3 id=logging>Logging<a hidden class=anchor aria-hidden=true href=#logging>#</a></h3>
<p>写入DRAM的同时需要记录日志（带来了写放大）
写入NVM的直接in-place更新</p>
<h3 id=recovery>Recovery<a hidden class=anchor aria-hidden=true href=#recovery>#</a></h3>
<p>故障时可能存在两种情况</p>
<ol>
<li>Vi写入DRAM memtable，但还没compaction
Vi+1正在写入NVM memtable</li>
<li>Vi已经写入NVM memtable
Vi+1正在写入DRAM memtable</li>
</ol>
<p>为了保证Recovery时的正确性：</p>
<ol>
<li>对于每个DRAM memtable都有一个新的log file</li>
<li>正在写入NVM memtable时不需要log file，NVM memtable就可以被视作一个log file</li>
<li>NVM log file有递增的version number</li>
</ol>
<p>Recovery时按照version number递增顺序恢复</p>
<p>发生故障时
写入DRAM的需要从logging文件进行Recovery。
写入NVM的memtable可以直接看作是一个日志文件，它同时需要一个存储跳表起始指针和其他元数据的额外文件从而在Recovery时定位数据。恢复时只需要进行内存映射即可。</p>
<h2 id=supporting-read-parallelism>Supporting Read Parallelism<a hidden class=anchor aria-hidden=true href=#supporting-read-parallelism>#</a></h2>
<h3 id=reducing-read-latency>Reducing read latency<a hidden class=anchor aria-hidden=true href=#reducing-read-latency>#</a></h3>
<p>常规的LSM中:
使用一个线程自上向下mutable memtable -> immutable memtable -> SSTable
在本设计中:
DRAM memtable 和 NVM memtable使用一个线程
DRAM immutable 和 NVM immutable使用一个线程
SSTable使用一个线程</p>
<p>因此时间从
$T_{read} ≈ T_{mem_{DRAM}} + T_{mem_{NVM}} + T_{imm} + T_{SST} $
压缩为
$T_{read_parallel} ≈ max(T_{mem_{DRAM}} + T_{mem_{NVM}}, T_{imm}, T_{SST}) + C$
$C$是常量，代表了找到结果后停止其他线程所需的时间</p>
<h3 id=guaranteeing-version-correctness-for-reads>Guaranteeing version correctness for reads.<a hidden class=anchor aria-hidden=true href=#guaranteeing-version-correctness-for-reads>#</a></h3>
<p>更高层(memtable->immu->sstable)往往是最新的数据，版本号最新。</p>
<ul>
<li>负责更高层的thread找到结果后停止其他线程</li>
<li>负责更低层的thread找到结果后，先等待更高层的执行完</li>
</ul>
<h3 id=optimistic-parallelism-and-management>Optimistic parallelism and management.<a hidden class=anchor aria-hidden=true href=#optimistic-parallelism-and-management>#</a></h3>
<p>多线程也带来了管理成本</p>
<ul>
<li>把多线程分配到不同的cpu上</li>
<li>为DRAM和NVM memtable添加bloom filter，只有bloom filter miss的时候，才开启多线程查询，否则就只使用单线程。</li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://zhangyh.me/tags/lsm-tree/>LSM-Tree</a></li>
<li><a href=https://zhangyh.me/tags/nvm/>NVM</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://zhangyh.me/posts/paper/21-8/optane/>
<span class=title>« Prev Page</span>
<br>
<span>An Empirical Guide to the Behavior and Use of Scalable Persistent Memory</span>
</a>
<a class=next href=https://zhangyh.me/posts/paper/21-8/zen/>
<span class=title>Next Page »</span>
<br>
<span>Zen: a high-throughput log-free OLTP engine for non-volatile main memory</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://zhangyh.me/>yuler's blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>